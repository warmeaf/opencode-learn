# 系统集成：从 OpenCode 代码库学到的经验

> 基于 `packages/opencode` 的代码分析

> 适用读者：具备前端开发经验，想了解后端/系统集成设计的工程师

---

## 目录

1. [什么是系统集成？](#什么是系统集成)
2. [具体实现：OpenCode 的四种集成模式](#具体实现opencode-的四种集成模式)
3. [抽象经验：可复用的设计原则](#抽象经验可复用的设计原则)
4. [实践指南：如何设计系统集成](#实践指南如何设计系统集成)

---

## 什么是系统集成？

### 通俗定义

**系统集成 = 让不同的系统能够协同工作**

在前端领域，你可能熟悉：

- 组件之间通过 Props/Events 通信
- 通过 API 与后端交互
- 使用第三方库（如 React Router、Redux）

在后端/系统集成领域，概念类似，但范围更大：

- 不同服务之间通信（HTTP、WebSocket、gRPC）
- 与外部工具/平台集成（GitHub、Slack、数据库）
- 支持多种客户端（CLI、Web、IDE）

### OpenCode 的集成场景

OpenCode 是一个 AI 代理平台，它需要集成：

| 集成对象         | 集成方式      | 目的                                      |
| ---------------- | ------------- | ----------------------------------------- |
| **IDE (Zed 等)** | ACP 协议      | 让用户在编辑器中使用 AI                   |
| **外部工具**     | MCP 协议      | 扩展 AI 的能力（读写 GitHub、搜索文件等） |
| **自定义扩展**   | Plugin 系统   | 允许用户/第三方开发功能扩展               |
| **前端客户端**   | SDK (OpenAPI) | 自动生成类型安全的 API 客户端             |

---

## 具体实现：OpenCode 的四种集成模式

### 模式一：协议集成 - ACP (Agent Client Protocol)

**场景**：让 IDE 能够与 AI 代理通信

**关键文件**：`src/acp/agent.ts`

#### 核心思路

```
┌─────────────┐         JSON-RPC over stdio         ┌─────────────┐
│  Zed Editor │ ←─────────────────────────────────→ │ OpenCode    │
│   (Client)  │    通过标准输入输出进行通信          │  (Agent)    │
└─────────────┘                                      └─────────────┘
```

#### 代码剖析

**1. 握手阶段 - 告诉对方我是谁、我能做什么**

```typescript
// src/acp/agent.ts
async initialize(params: InitializeRequest): Promise<InitializeResponse> {
  return {
    protocolVersion: 1,
    agentCapabilities: {
      loadSession: true,           // 能加载会话
      mcpCapabilities: {            // 支持 MCP 协议
        http: true,
        sse: true
      },
      promptCapabilities: {         // 支持的提示类型
        embeddedContext: true,
        image: true
      }
    },
    authMethods: ["oauth", "token"], // 支持的认证方式
    agentInfo: {
      name: "OpenCode",
      version: "1.1.3"
    }
  }
}
```

**要点**：

- 协议第一步永远是"握手"，交换能力和期望
- 类比前端：协商 WebRTC 连接时交换 SDP

**2. 创建会话 - 建立通信上下文**

```typescript
async newSession(params: NewSessionRequest) {
  // 在服务端创建会话状态
  const state = await this.sessionManager.create(params.cwd, params.mcpServers)

  // 订阅会话事件，实现实时推送
  this.setupEventSubscriptions(state)

  return {
    sessionId: state.id,
    models: await Provider.listModels(),  // 可用的 AI 模型
    modes: ["build", "plan", "zen"]       // 可用的代理模式
  }
}
```

**要点**：

- 会话 = 一次完整的交互上下文
- 前端类比：WebSocket 连接后创建一个 session 对象

**3. 事件转发 - 让 IDE 实时感知 AI 行为**

```typescript
private setupEventSubscriptions(session: ACPSessionState) {
  // 订阅服务端的所有事件
  this.config.sdk.event.subscribe({ directory }).then(async (events) => {
    for await (const event of events.stream) {
      switch (event.type) {
        case "permission.asked":
          // 转发给 IDE 请求权限
          await this.connection.requestPermission({
            sessionId,
            toolCall: { /* ... */ },
            options: [
              { optionId: "once", kind: "allow_once" },
              { optionId: "always", kind: "allow_always" }
            ]
          })
          break

        case "message.part.updated":
          // 转发消息增量更新（流式输出）
          await this.connection.sessionUpdate({
            sessionId,
            update: {
              sessionUpdate: "agent_message_chunk",
              content: { type: "text", text: event.properties.delta }
            }
          })
          break
      }
    }
  })
}
```

**要点**：

- 事件转发 = 当系统内部有事情发生时，告诉外部
- 类比前端：Redux 中间件监听 action 并发送到其他系统

#### 可复用经验

| 经验             | 说明                           |
| ---------------- | ------------------------------ |
| **协议优先**     | 先定义协议（接口），再实现细节 |
| **握手交换能力** | 初次连接时交换"我能做什么"     |
| **会话即上下文** | 一次对话需要持久的状态         |
| **事件驱动同步** | 用事件流而不是轮询来同步状态   |
| **渐进式交互**   | 支持流式返回，不要等全部完成   |

---

### 模式二：协议集成 - MCP (Model Context Protocol)

**场景**：让 AI 能够调用外部工具（如 GitHub API）

**关键文件**：`src/mcp/index.ts`

#### 核心思路

```
┌─────────────┐         MCP 协议          ┌─────────────┐
│ OpenCode    │ ←────────────────────────→ │ GitHub MCP  │
│  (Agent)    │    获取工具列表、执行工具   │  (Server)   │
└─────────────┘                            └─────────────┘
```

MCP 是一个开放协议，用于扩展 AI 的上下文能力（工具、资源、提示词）。

#### 代码剖析

**1. 多种连接方式 - 灵活适配不同场景**

```typescript
// src/mcp/index.ts
type McpConfig =
  // 方式一：本地进程（通过 stdio 通信）
  | { type: "local", command: string[], args: string[], env: Record<string, string> }
  // 方式二：远程 HTTP/SSE
  | { type: "remote", url: string, headers?: Record<string, string> }

// 本地进程示例
{
  type: "local",
  command: "node",
  args: ["./github-mcp-server.js"]
}

// 远程服务示例
{
  type: "remote",
  url: "https://mcp.github.com",
  oauth: true  // 需要 OAuth 认证
}
```

**要点**：

- 协议不限制传输方式，只规定消息格式
- 前端类比：REST API 可以用 HTTP 也可以用 GraphQL

**2. 工具转换 - MCP 工具 → AI SDK 工具**

```typescript
export async function tools() {
  const result: Record<string, Tool> = {}
  const s = await state()
  const clientsSnapshot = await clients()

  // 遍历所有已连接的 MCP 客户端
  for (const [clientName, client] of Object.entries(clientsSnapshot)) {
    // 只处理已连接的 MCP 服务器
    if (s.status[clientName]?.status !== "connected") continue

    // 获取该 MCP 服务器的工具列表
    const toolsResult = await client.listTools()

    for (const mcpTool of toolsResult.tools) {
      // 清理客户端名称和工具名称（移除非字母数字字符）
      // 避免命名冲突，例如 "github-mcp" 和 "github/mcp" 都会变成 "github_mcp"
      const sanitizedClientName = clientName.replace(/[^a-zA-Z0-9_-]/g, "_")
      const sanitizedToolName = mcpTool.name.replace(/[^a-zA-Z0-9_-]/g, "_")

      // 转换为 AI SDK 可以理解的工具格式
      result[`${sanitizedClientName}_${sanitizedToolName}`] = await convertMcpTool(mcpTool, client)
    }
  }

  return result
}
```

**要点**：

- 外部系统的工具需要"翻译"成内部格式
- 前端类比：API 响应的数据映射到 TypeScript 类型
- 工具名称需要清理，避免特殊字符导致的问题

**3. OAuth 认证流程 - 处理需要授权的服务**

```typescript
async authenticate(mcpName: string): Promise<Status> {
  // 步骤 1: 启动认证，获取授权 URL
  const { authorizationUrl, oauthState } = await startAuth(mcpName)

  // 步骤 2: 打开浏览器让用户授权
  await open(authorizationUrl)

  // 步骤 3: 等待回调
  const code = await McpOAuthCallback.waitForCallback(oauthState)

  // 步骤 4: 完成认证
  return finishAuth(mcpName, code)
}
```

**要点**：

- 复杂的认证流程需要多次交互
- 前端类比：OAuth 登录（点击授权 → 回调获取 code）

#### 可复用经验

| 经验               | 说明                                              |
| ------------------ | ------------------------------------------------- |
| **协议与传输分离** | 协议定义消息格式，传输可以是 HTTP、stdio 等       |
| **适配器模式**     | 外部接口需要转换为内部统一格式                    |
| **状态管理**       | 连接状态（connected/failed/needs_auth）需要持久化 |
| **认证分离**       | 认证是独立流程，不应阻塞正常功能                  |

---

### 模式三：插件系统

**场景**：允许用户/第三方扩展功能

**关键文件**：`src/plugin/index.ts`、`packages/plugin/src/index.ts`

#### 核心思路

```
┌─────────────────────────────────────────────────────────┐
│                    OpenCode Core                         │
│                                                          │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │  Event   │  │  Config  │  │  Tool    │              │
│  │   Hook   │  │   Hook   │  │   Hook   │              │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘              │
└───────┼────────────┼────────────┼───────────────────────┘
        │            │            │
        └────────────┼────────────┘
                     │
        ┌────────────┴────────────┐
        │     Plugin (用户代码)    │
        │  - 监听事件              │
        │  - 修改配置              │
        │  - 注册工具              │
        └─────────────────────────┘
```

#### 代码剖析

**1. 插件接口定义 - 提供扩展点**

```typescript
// packages/plugin/src/index.ts
export interface Hooks {
  // 配置钩子：启动时修改配置
  config?: (input: Config) => Promise<void>

  // 事件钩子：所有事件都会触发
  event?: (input: { event: Event }) => Promise<void>

  // 聊天消息钩子
  "chat.message"?: (input, output) => Promise<void>
  "chat.params"?: (input, output) => Promise<void>

  // 权限钩子：工具执行前请求权限
  "permission.ask"?: (input: Permission, output) => Promise<void>

  // 工具执行钩子
  "tool.execute.before"?: (input, output) => Promise<void>
  "tool.execute.after"?: (input, output) => Promise<void>

  // 工具注册：添加自定义工具
  tool?: { [key: string]: ToolDefinition }

  // 认证钩子：提供自定义认证方式
  auth?: AuthHook

  // 实验性钩子
  "experimental.chat.messages.transform"?: (input, output) => Promise<void>
  "experimental.chat.system.transform"?: (input, output) => Promise<void>
  "experimental.session.compacting"?: (input, output) => Promise<void>
  "experimental.text.complete"?: (input, output) => Promise<void>
}
```

**要点**：

- 钩子 = "在某个时刻执行你的代码"
- 前端类比：React 生命周期函数、Vite 插件钩子
- `tool` 钩子允许插件注册自定义工具，扩展 AI 的能力

**2. 插件加载 - 支持本地文件和 npm 包**

```typescript
// src/plugin/index.ts
const state = Instance.state(async () => {
  const hooks = []

  // 准备插件输入（提供 API 给插件使用）
  const input: PluginInput = {
    client: createOpencodeClient({
      baseUrl: "http://localhost:4096",
      fetch: async (...args) => Server.App().fetch(...args),
    }),
    project: Instance.project,
    worktree: Instance.worktree,
    directory: Instance.directory,
    serverUrl: Server.url(),
    $: Bun.$, // Shell 执行能力
  }

  // 加载配置中的插件
  for (let plugin of config.plugin ?? []) {
    // 如果是 npm 包，先安装
    if (!plugin.startsWith("file://")) {
      // 解析包名和版本（支持 "pkg@version" 格式）
      const lastAtIndex = plugin.lastIndexOf("@")
      const pkg = lastAtIndex > 0 ? plugin.substring(0, lastAtIndex) : plugin
      const version = lastAtIndex > 0 ? plugin.substring(lastAtIndex + 1) : "latest"
      plugin = await BunProc.install(pkg, version)
    }

    // 动态导入插件模块
    const mod = await import(plugin)

    // 调用插件函数，获取钩子（避免重复初始化）
    const seen = new Set<Plugin>()
    for (const [_name, fn] of Object.entries<Plugin>(mod)) {
      if (seen.has(fn)) continue
      seen.add(fn)
      const init = await fn(input)
      hooks.push(init)
    }
  }

  return { hooks, input }
})
```

**要点**：

- 插件本质上是一个函数，接收 context，返回 hooks
- 前端类比：Vite 插件是一个返回配置对象的函数
- `worktree` 和 `serverUrl` 提供了额外的项目上下文和服务器连接信息

**3. 钩子触发 - 在特定时机调用插件**

```typescript
export async function trigger<Name extends keyof Hooks>(
  name: Name,
  input: Parameters<Required<Hooks>[Name]>[0],
  output: Parameters<Required<Hooks>[Name]>[1],
): Promise<Output> {
  // 遍历所有已加载的插件
  for (const hook of await state().then((x) => x.hooks)) {
    const fn = hook[name]
    if (!fn) continue

    // 调用插件的钩子函数
    await fn(input, output)
  }

  return output
}
```

**要点**：

- 触发钩子 = 遍历所有插件，执行对应的方法
- 前端类比：Redux 中间件链式执行

**4. 实际插件示例**

```typescript
// 一个简单的 Slack 通知插件
import { Plugin } from "@opencode-ai/plugin"

export default async function slackNotification({ client, $ }: PluginInput) {
  return {
    // 工具执行后发送通知
    "tool.execute.after": async ({ tool, sessionID }, { output }) => {
      if (tool === "write") {
        await $`slack-cli send "File edited: ${output.title}"`
      }
    },
  }
}
```

#### 可复用经验

| 经验             | 说明                              |
| ---------------- | --------------------------------- |
| **约定优于配置** | 插件只需导出符合签名的函数        |
| **依赖注入**     | 通过参数传递能力（API、Shell 等） |
| **钩子设计**     | 提供足够的扩展点，但不要过度设计  |
| **隔离性**       | 插件错误不应影响主系统            |
| **热加载**       | 开发时支持插件重新加载            |

---

### 模式四：SDK 自动生成

**场景**：让外部系统能方便地调用 API

**关键文件**：`src/server/server.ts`、`packages/sdk/js/`

#### 核心思路

```
┌────────────────────────────────────────────────────────┐
│              Server (Hono + OpenAPI)                   │
│  定义路由 → 自动生成 OpenAPI 规范 → 生成 SDK            │
└────────────────────┬───────────────────────────────────┘
                     │
                     ↓
┌────────────────────────────────────────────────────────┐
│              Generated SDK (TypeScript)                │
│  - 类型安全的 API 调用                                  │
│  - 自动补全                                            │
│  - 与服务器定义同步                                     │
└────────────────────────────────────────────────────────┘
```

#### 代码剖析

**1. 服务器端定义 - 用装饰器定义 OpenAPI**

```typescript
// src/server/server.ts
import { describeRoute, validator, resolver, openAPIRouteHandler } from "hono-openapi"

app.get(
  "/session/:sessionID",
  describeRoute({
    summary: "Get session info",
    operationId: "session.get",
    tags: ["Session"],
    responses: {
      200: {
        description: "Session info",
        content: {
          "application/json": {
            schema: resolver(Session.Info), // 自动从 Zod schema 生成
          },
        },
      },
    },
  }),
  async (c) => {
    const sessionID = c.req.param("sessionID")
    return c.json(await Session.get(sessionID))
  },
)

// 导出 OpenAPI 规范
app.get("/openapi.json", openAPIRouteHandler)
```

**要点**：

- 代码即文档，API 定义和文档在一起
- 前端类比：类似 tRPC，从类型生成 API

**2. 使用 SDK - 类型安全的 API 调用**

```typescript
// 用户代码
import { createOpencodeClient } from "@opencode-ai/sdk"

const client = createOpencodeClient({
  baseUrl: "http://localhost:4096",
})

// 完全类型安全！
const session = await client.session.get({
  sessionID: "ses_123",
})

// TypeScript 知道 session 的类型
console.log(session.agent) // 类型是 string
```

**要点**：

- SDK = HTTP 客户端 + 类型定义
- 前端类比：类似 Axios 但类型完全由服务器定义驱动

#### 可复用经验

| 经验           | 说明                         |
| -------------- | ---------------------------- |
| **代码即文档** | API 定义和文档应该在一起维护 |
| **类型安全**   | 从服务器到客户端的类型流     |
| **自动化**     | 代码生成减少手动维护         |
| **版本兼容**   | API 变更时考虑版本管理       |

---

## 抽象经验：可复用的设计原则

### 原则一：协议标准化

**问题**：不同系统之间如何通信？

**答案**：定义协议，而不是具体实现

```
协议 = 接口定义 + 数据格式 + 交互流程
```

| 协议    | 用途            | 类比                     |
| ------- | --------------- | ------------------------ |
| ACP     | IDE ↔ AI 代理   | WebRTC (浏览器 ↔ 浏览器) |
| MCP     | AI ↔ 工具提供者 | REST API (前端 ↔ 后端)   |
| OpenAPI | Server ↔ Client | GraphQL                  |

**实践要点**：

1. 协议与传输分离：协议定义消息格式，传输可以是 HTTP、stdio、WebSocket
2. 版本管理：协议变更时要考虑向后兼容
3. 能力协商：连接时交换"我能做什么"

### 原则二：事件驱动架构

**问题**：系统内部模块如何通信？

**答案**：发布-订阅模式

```typescript
// 定义事件
export const MessageUpdated = BusEvent.define(
  "message.updated",
  z.object({
    messageID: z.string(),
    content: z.string(),
  }),
)

// 发布事件
await Bus.publish(MessageUpdated, {
  messageID: "msg_123",
  content: "Hello",
})

// 订阅事件
Bus.subscribe(MessageUpdated, async (event) => {
  console.log("New message:", event.properties.content)
})
```

**优点**：

- 松耦合：发布者不需要知道订阅者
- 易扩展：添加新功能只需订阅事件
- 可测试：可以独立测试每个模块

**类比前端**：

- Redux dispatch/store
- Node.js EventEmitter
- 浏览器 CustomEvent

### 原则三：依赖注入

**问题**：如何让插件访问系统能力？

**答案**：通过参数传递，而不是全局变量

```typescript
// ❌ 不好：插件直接导入
import { Session } from "./session" // 耦合！

// ✅ 好：通过参数注入
export default function myPlugin({ client, $ }: PluginInput) {
  // client 和 $ 是从外部传入的
}
```

**优点**：

- 可测试：可以注入 mock 对象
- 灵活：可以替换实现
- 明确：依赖关系一目了然

**类比前端**：

- React Context
- Vue provide/inject

### 原则四：适配器模式

**问题**：如何集成不同的外部系统？

**答案**：转换为统一的内部格式

```typescript
// MCP 工具 → AI SDK 工具
async function convertMcpTool(mcpTool: MCPTool, client: Client): Promise<Tool> {
  return {
    description: mcpTool.description,
    parameters: jsonSchema(mcpTool.inputSchema),
    execute: async (args) => {
      const result = await client.callTool({
        name: mcpTool.name,
        arguments: args,
      })
      return result.content
    },
  }
}
```

**要点**：

- 外部接口可能千差万别
- 内部系统只关心统一格式
- 适配器负责转换

### 原则五：命名空间模式

**问题**：如何组织代码结构？

**答案**：按功能模块命名空间

```typescript
// ❌ 不好：散乱的导出
export function createSession() { }
export function getSession() { }
export function removeSession() { }

// ✅ 好：命名空间组织
export namespace Session {
  export const create = fn(...)
  export const get = fn(...)
  export const remove = fn(...)
}
```

**优点**：

- 相关功能聚合
- 避免命名冲突
- 易于导航

**使用**：

```typescript
import { Session } from "./session"
await Session.create()
```

---

## 实践指南：如何设计系统集成

### 步骤一：明确集成目标

问自己几个问题：

1. 要集成的系统是什么？（服务、设备、平台）
2. 集成的目的是什么？（数据交换、功能调用、事件通知）
3. 谁是主动方？（本地调用远程，还是远程推送到本地）

### 步骤二：选择集成方式

根据场景选择合适的模式：

| 场景             | 推荐方式                  | 参考        |
| ---------------- | ------------------------- | ----------- |
| 需要实时双向通信 | WebSocket、协议（如 ACP） | ACP 实现    |
| 简单的功能调用   | REST API                  | SDK 生成    |
| 扩展系统能力     | 插件系统                  | Plugin 实现 |
| 引入外部工具     | 协议适配（如 MCP）        | MCP 实现    |
| 系统间解耦通信   | 事件总线                  | Bus 实现    |

### 步骤三：定义协议/接口

如果是双向集成，需要定义协议：

```typescript
// 1. 定义消息类型
export const MessageType = {
  HELLO: "hello",
  REQUEST: "request",
  RESPONSE: "response",
  EVENT: "event",
} as const

// 2. 定义数据结构
export const HelloMessage = z.object({
  type: z.literal(MessageType.HELLO),
  version: z.string(),
  capabilities: z.array(z.string()),
})

// 3. 定义流程
// Client → Server: HELLO
// Server → Client: HELLO_ACK
// Client → Server: REQUEST
// Server → Client: RESPONSE
```

### 步骤四：实现适配层

把外部系统转换为内部格式：

```typescript
// 适配器模板
class ExternalSystemAdapter {
  // 外部客户端
  private client: ExternalClient

  // 初始化连接
  async connect(config: Config) {
    this.client = new ExternalClient(config.endpoint)
    await this.client.connect()
  }

  // 转换外部数据为内部格式
  async getData(): Promise<InternalData> {
    const external = await this.client.fetch()
    return {
      id: external.id,
      name: external.name,
      // ... 字段映射
    }
  }

  // 转换内部请求为外部调用
  async execute(request: InternalRequest): Promise<InternalResponse> {
    const externalRequest = {
      method: request.action,
      params: request.params,
    }
    const external = await this.client.call(externalRequest)
    return {
      success: external.ok,
      data: external.result,
    }
  }
}
```

### 步骤五：添加事件通知

让外部变化能及时反映到内部：

```typescript
// 订阅外部事件
externalClient.on("changed", async (externalEvent) => {
  // 转换为内部事件
  const internalEvent = convertEvent(externalEvent)

  // 发布到内部事件总线
  await Bus.publish(ExternalDataChanged, {
    source: "external-system",
    data: internalEvent,
  })
})
```

### 步骤六：错误处理和重试

```typescript
async function withRetry<T>(fn: () => Promise<T>, options: { maxRetries: number; delay: number }): Promise<T> {
  let lastError: Error
  for (let i = 0; i < options.maxRetries; i++) {
    try {
      return await fn()
    } catch (error) {
      lastError = error
      await sleep(options.delay * (i + 1)) // 指数退避
    }
  }
  throw lastError
}
```

### 步骤七：状态管理

```typescript
export const ConnectionState = z.discriminatedUnion("status", [
  z.object({ status: z.literal("connecting") }),
  z.object({ status: z.literal("connected"), since: z.date() }),
  z.object({ status: z.literal("disconnected"), reason: z.string() }),
  z.object({ status: z.literal("error"), error: z.string() }),
])
```

---

## 总结

### 系统集成的本质

系统集成 = **标准化接口 + 适配器 + 事件驱动**

1. **标准化接口**：定义清晰的协议/接口
2. **适配器**：转换外部系统为内部格式
3. **事件驱动**：松耦合的模块间通信

### 前端工程师的优势

你已经有很多可迁移的经验：

| 前端概念         | 后端集成类比  |
| ---------------- | ------------- |
| Props/Events     | 协议/事件总线 |
| API 调用         | HTTP/gRPC     |
| 第三方库         | MCP/插件系统  |
| 状态管理 (Redux) | 事件总线      |
| TypeScript 类型  | 协议定义/SDK  |

### 关键文件索引

| 功能     | 文件路径                       |
| -------- | ------------------------------ |
| ACP 协议 | `src/acp/agent.ts`             |
| MCP 集成 | `src/mcp/index.ts`             |
| 插件系统 | `src/plugin/index.ts`          |
| 事件总线 | `src/bus/index.ts`             |
| SDK 生成 | `packages/sdk/js/openapi.json` |

### 进一步学习建议

1. **动手实践**：尝试写一个简单的插件
2. **阅读协议**：了解 ACP 和 MCP 的规范
3. **观察数据流**：用调试工具追踪一次完整的请求流程
4. **对比学习**：对比其他项目的集成方式（如 VS Code 扩展）

---

_文档生成时间：2026-01-06_
_基于 OpenCode dev 分支_
