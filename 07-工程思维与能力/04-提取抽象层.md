# 提取抽象层

## 概述

当多个子模块共享相同的底层依赖时，可以提取一个抽象层来统一接口。

抽象层将具体实现细节封装起来，让上层模块通过简洁的 API 进行交互。

---

## 作用

降低模块间的耦合度，提高代码的可维护性和可测试性。

通过抽象层，可以在不修改上层模块的情况下替换底层实现。

---

## 使用场景

### 多个模块共享依赖

当多个子模块都需要访问同一个底层系统时：

```typescript
// 不好的做法：每个模块直接依赖具体实现
import { FileSystem } from "./fs"
// 模块 A 和模块 B 都直接导入 FileSystem

// 好的做法：提取抽象层
// storage.ts
export const Storage = { read, write, update, remove }

// 所有模块通过统一的 Storage API 操作
import { Storage } from "./storage"
await Storage.write(["session", projectID, sessionID], data)
await Storage.read<Session.Info>(["session", projectID, sessionID])
await Storage.update(["session", projectID, sessionID], (draft) => {
  draft.title = "new title"
})
```

### 需要可替换性

当底层实现可能发生变化时：

```typescript
// 抽象层让实现可以无缝切换
// 比如：文件系统 → 数据库 → 云存储

// 只需修改 Storage 内部实现
// 不用改所有使用方的代码
```

### 需要统一接口

当操作比较复杂，需要封装时：

```typescript
// 复杂逻辑封装在抽象层内部
await Storage.update(["session", id], (draft) => {
  // 自动处理并发、乐观锁、事务等
})

// 使用方不需要关心细节
```

### 需要统一行为

当需要统一的横切关注点时：

- 统一的日志记录
- 统一的错误处理
- 统一的性能监控
- 统一的权限检查

---

## 项目中的例子

### Storage 抽象层

所有持久化操作通过统一的 Storage API：

```typescript
import { Storage } from "../storage/storage"

// 读取
const session = await Storage.read<Session.Info>(["session", projectID, sessionID])

// 写入
await Storage.write(["session", projectID, sessionID], data)

// 列出
for (const item of await Storage.list(["session", projectID])) {
  const session = await Storage.read<Session.Info>(item)
}

// 更新
await Storage.update<Session.Info>(["session", projectID, sessionID], (draft) => {
  draft.title = "new title"
})

// 删除
await Storage.remove(["session", projectID, sessionID])
```

### Bus 事件总线

所有模块间通信通过事件总线：

```typescript
import { Bus } from "@/bus"

// 发布事件
Bus.publish(Session.Event.Created, { info: result })
Bus.publish(MessageV2.Event.Updated, { info: msg })

// 订阅事件
Bus.subscribe(Session.Event.Updated, (data) => {
  // 处理更新
})
```

### LLM 提供商抽象

统一的 LLM 接口支持多个提供商：

```typescript
import { LLM } from "./session/llm"
import { Provider } from "./provider/provider"

// 使用相同的接口调用不同提供商
const model = await Provider.getModel("anthropic", "claude-3-5-sonnet")
const stream = await LLM.stream({
  user: userMessage,
  sessionID: session.id,
  model: model,
  agent: agentInfo,
  system: ["system prompt..."],
  abort: abortController.signal,
  messages,
  tools,
})

// 可以无缝切换到其他提供商
const model = await Provider.getModel("openai", "gpt-4")
const stream = await LLM.stream({
  user: userMessage,
  sessionID: session.id,
  model: model,
  agent: agentInfo,
  system: ["system prompt..."],
  abort: abortController.signal,
  messages,
  tools,
})
```

---

## 设计原则

保持抽象层简单明了。

只暴露必要的操作，隐藏实现细节。

避免过度抽象，不要为了抽象而抽象。

根据实际需求逐步添加抽象层。
