# 循环结束机制

## 一、外层循环的结束

外层循环位于 `packages/opencode/src/session/prompt.ts:257`，采用 `while (true)` 无限循环形式，通过多种条件判断来退出。

### 1. 主要退出条件

#### 1.1 任务完成 - 正常退出

**代码位置**：`packages/opencode/src/session/prompt.ts:294-301`

```typescript
if (
  lastAssistant?.finish &&
  !["tool-calls", "unknown"].includes(lastAssistant.finish) &&
  lastUser.id < lastAssistant.id
) {
  log.info("exiting loop", { sessionID })
  break
}
```

**退出条件**：

- 最后一条助手消息有 `finish` 状态
- `finish` 状态不是 `"tool-calls"` 或 `"unknown"`（即 LLM 正常完成任务）
- 助手消息的 ID 大于用户消息 ID（确保助手是在用户消息之后完成的）

**含义**：LLM 判定任务已完成，返回了最终结果（如文本回答、代码等），而不是要求继续调用工具。

#### 1.2 用户中止

**代码位置**：`packages/opencode/src/session/prompt.ts:273`

```typescript
if (abort.aborted) break
```

**退出条件**：用户通过 AbortController 主动中止了任务

**含义**：用户在 TUI/CLI 中按了 Ctrl+C 或点击了"停止"按钮。

#### 1.3 内层循环返回停止

**代码位置**：`packages/opencode/src/session/prompt.ts:565-594`

```typescript
const result = await processor.process({
  user: lastUser,
  agent,
  abort,
  sessionID,
  system: [...(await SystemPrompt.environment()), ...(await SystemPrompt.custom())],
  messages: [
    ...MessageV2.toModelMessage(sessionMessages),
    ...(isLastStep
      ? [
          {
            role: "assistant" as const,
            content: MAX_STEPS,
          },
        ]
      : []),
  ],
  tools,
  model,
})
if (result === "stop") break
if (result === "compact") {
  await SessionCompaction.create({
    sessionID,
    agent: lastUser.agent,
    model: lastUser.model,
    auto: true,
  })
}
```

**退出条件**：内层循环处理完成后返回 `"stop"` 状态

**含义**：内层循环遇到不可恢复的错误，或者任务被阻塞。

#### 1.4 压缩任务停止

**代码位置**：`packages/opencode/src/session/prompt.ts:481-490`

```typescript
if (task?.type === "compaction") {
  const result = await SessionCompaction.process({...})
  if (result === "stop") break
  continue
}
```

**退出条件**：执行消息压缩任务时，返回 `"stop"` 状态

**含义**：会话压缩失败或达到停止条件。

### 2. 退出逻辑总结

| 退出方式 | 触发条件                                 | 代码位置  | 备注               |
| -------- | ---------------------------------------- | --------- | ------------------ |
| 正常完成 | LLM 返回最终答案                         | 294-301行 | 最常见的退出方式   |
| 用户中止 | `abort.aborted = true`                   | 273行     | 用户主动停止       |
| 内层返回 | `processor.process() === "stop"`         | 585行     | 内层遇到错误或阻塞 |
| 压缩停止 | `SessionCompaction.process() === "stop"` | 489行     | 会话压缩失败       |

---

## 二、内层循环的结束

内层循环位于 `packages/opencode/src/session/processor.ts:48`（process 方法的 `while (true)` 循环开始处），同样采用 `while (true)` 无限循环，但结构更复杂。

### 1. 循环结构

```typescript
while (true) {
  // 内层外层循环 - 重试循环
  try {
    const stream = await LLM.stream(streamInput)

    for await (const value of stream.fullStream) {
      // 内层内层循环 - 流处理循环
      switch (value.type) {
        case "tool-call":
          // 执行工具
          break
        case "tool-result":
          // 接收工具结果
          break
        case "finish":
          // LLM 完成输出
          break
      }
    }
  } catch (e: any) {
    // 错误处理
    if (retryable) {
      attempt++
      continue // 重试，继续外层循环
    }
    // 不可重试的错误，直接跳出
  }

  // 返回退出状态
  if (needsCompaction) return "compact"
  if (blocked) return "stop"
  if (input.assistantMessage.error) return "stop"
  return "continue"
}
```

### 2. 内层内层循环的结束（流处理循环）

**循环形式**：`for await (const value of stream.fullStream)`

**退出条件**：LLM 流式输出完全结束

**关键事件**：`case "finish"`

```typescript
case "finish":
  // 标记流式输出结束，准备退出内层循环
  break
```

**含义**：

- LLM 已经完成所有输出（包括推理、文本、工具调用）
- `break` 会跳出 `for await` 循环
- 代码继续执行到外层的返回逻辑

**其他可能的退出方式**：

- 流式输出过程中发生异常（通过 `try-catch` 捕获）
- `input.abort.throwIfAborted()` 检测到中止信号

### 3. 内层外层循环的结束（重试循环）

#### 3.1 正常退出

**代码位置**：`packages/opencode/src/session/processor.ts:393-396`

```typescript
if (needsCompaction) return "compact"
if (blocked) return "stop"
if (input.assistantMessage.error) return "stop"
return "continue"
```

**退出状态说明**：

| 返回值       | 含义                                  | 外层循环的处理             |
| ------------ | ------------------------------------- | -------------------------- |
| `"continue"` | 本轮 LLM 调用正常完成，需要继续下一步 | 继续下一轮外层循环         |
| `"stop"`     | 任务完成或遇到不可恢复错误            | 退出外层循环               |
| `"compact"`  | Token 使用量超过阈值，需要压缩        | 外层创建压缩任务，然后继续 |

#### 3.2 异常重试退出

**代码位置**：`packages/opencode/src/session/processor.ts:335-358`

```typescript
catch (e: any) {
  log.error("process", { error: e, stack: JSON.stringify(e.stack) })
  const error = MessageV2.fromError(e, { providerID: input.model.providerID })
  const retry = SessionRetry.retryable(error)

  if (retry !== undefined) {
    attempt++
    const delay = SessionRetry.delay(attempt, error.name === "APIError" ? error : undefined)
    SessionStatus.set(input.sessionID, {
      type: "retry",
      attempt,
      message: retry,
      next: Date.now() + delay,
    })
    await SessionRetry.sleep(delay, input.abort).catch(() => {})
    continue  // 重试，继续外层循环
  }

  input.assistantMessage.error = error
  Bus.publish(Session.Event.Error, {
    sessionID: input.assistantMessage.sessionID,
    error: input.assistantMessage.error,
  })
}
```

**逻辑说明**：

1. **捕获异常**：通过 `try-catch` 捕获 LLM 调用或工具执行过程中的异常
2. **判断可重试性**：调用 `SessionRetry.retryable(error)` 判断错误是否可重试
3. **可重试错误**：
   - 增加重试次数 `attempt++`
   - 计算重试延迟 `delay`
   - 更新会话状态为 `"retry"`
   - 等待延迟时间
   - `continue` 重新开始内层循环
4. **不可重试错误**：
   - 记录错误到 `assistantMessage.error`
   - 发布错误事件
   - 跳出 `while (true)` 循环
   - 返回 `"stop"`（通过第395行的判断）

### 4. 重试机制详解

**代码位置**：`packages/opencode/src/session/retry.ts`

（假设存在，实际代码位置可能不同）

重试策略通常包括：

- **网络错误**：如超时、连接失败 → 可重试
- **API 限流**：如 429 错误 → 可重试，延迟指数增长
- **认证错误**：如 401/403 → 不可重试
- **参数错误**：如 400 → 不可重试
- **服务端错误**：如 500 → 可重试

重试延迟策略：

- 第1次重试：1秒
- 第2次重试：2秒
- 第3次重试：4秒
- ...
- 最大重试次数：通常 3-5 次

---

## 三、双层循环的协同结束

### 1. 完整结束流程

```
用户输入任务
    ↓
外层循环 step 1
    ↓
内层循环第1次
    ├─ for await 处理 LLM 流
    ├─ 处理工具调用
    └─ 收到 finish 事件
    ↓
返回 "continue"
    ↓
外层循环继续 step 2
    ↓
内层循环第2次
    ├─ for await 处理 LLM 流
    ├─ 处理工具调用
    └─ 收到 finish 事件
    ↓
返回 "stop"  ← LLM 判定任务完成
    ↓
外层循环退出
    ↓
任务完成
```

### 2. 异常场景的结束

```
外层循环 step N
    ↓
内层循环
    ├─ 调用 LLM 失败（网络超时）
    ├─ catch 捕获异常
    ├─ 判断可重试
    ├─ 延迟后 continue
    ├─ 再次调用 LLM，仍然失败
    ├─ 判断不可重试
    ├─ 设置 assistantMessage.error
    └─ 返回 "stop"
    ↓
外层循环退出
    ↓
任务失败，显示错误
```

### 3. 用户中止的结束

```
用户按 Ctrl+C
    ↓
abort.abort() 被调用
    ↓
外层循环检测到 abort.aborted
    ↓
外层循环立即退出
    ↓
（内层循环也会检测到 abort）
input.abort.throwIfAborted() 抛出异常
    ↓
内层循环退出
```

---

## 四、关键设计要点

### 1. 为什么用 `while (true)` + `break`？

**优点**：

- 简洁直观，逻辑清晰
- 可以在任意位置退出循环（通过多个 `break` 条件）
- 符合"持续执行直到满足条件"的语义

**缺点**：

- 需要仔细检查所有退出路径，避免死循环

### 2. 为什么外层和内层有不同的退出条件？

| 层级 | 关注点                | 退出条件                         | 返回值含义                  |
| ---- | --------------------- | -------------------------------- | --------------------------- |
| 外层 | 任务是否完成          | LLM 返回最终答案、错误、用户中止 | 无返回值（直接退出）        |
| 内层 | 单次 LLM 调用是否完成 | LLM 流结束、重试次数耗尽         | "continue"/"stop"/"compact" |

**原因**：

- 外层需要知道"整个任务是否完成"
- 内层只需要知道"这次调用是否成功，是否需要继续"

### 3. 重试机制如何保证不无限重试？

```typescript
let attempt = 0 // 重试计数器

if (retry !== undefined) {
  attempt++ // 每次重试增加计数

  // SessionRetry.delay() 会根据 attempt 计算延迟
  // 如果超过最大重试次数，返回 undefined
  const delay = SessionRetry.delay(attempt, error.name === "APIError" ? error : undefined)

  if (delay === undefined) {
    // 超过最大重试次数，不可再重试
    input.assistantMessage.error = error
    return "stop"
  }

  // 更新会话状态为重试中
  SessionStatus.set(input.sessionID, {
    type: "retry",
    attempt,
    message: retry,
    next: Date.now() + delay,
  })

  // 等待延迟时间（可以被 abort 中断）
  await SessionRetry.sleep(delay, input.abort).catch(() => {})
  continue
}
```

### 4. 如何优雅地中断流式输出？

```typescript
for await (const value of stream.fullStream) {
  input.abort.throwIfAborted() // 检查中止信号

  switch (
    value.type
    // 处理事件
  ) {
  }
}
```

当用户点击"停止"时：

1. 调用 `abort.abort()`
2. 下一次循环迭代时 `throwIfAborted()` 抛出异常
3. `catch` 捕获异常，设置错误状态
4. 返回 `"stop"`，外层循环退出

---

## 五、常见问题

### Q1: 为什么外层循环不直接返回，而是要用 break？

A: `while (true)` 循环中的 `break` 会跳出循环，然后继续执行循环后的代码（如果有）。在 OpenCode 的实现中，循环结束后会执行 `defer` 清理操作（第266行），然后返回最终结果。

### Q2: 内层循环的返回值是如何传递给外层的？

A: 通过 `processor.process()` 方法的返回值：

```typescript
const result = await processor.process({...})
if (result === "stop") break
if (result === "compact") {
  await SessionCompaction.create({...})
}
```

### Q3: 如果内层循环一直重试，怎么办？

A: `SessionRetry.delay()` 会根据重试次数指数增长延迟时间（1s, 2s, 4s, 8s...），并且有最大重试次数限制（通常 3-5 次），超过后返回 `undefined`，不再重试。

### Q4: 为什么有两种不同的循环结束方式？

A:

- `break`：用于跳出 `while (true)` 循环，控制流跳出后不再执行循环体
- `return`：用于从函数返回，传递状态给调用者
- 内层循环需要返回状态告诉外层"下一步该做什么"，所以用 `return`
- 外层循环只需要知道"是否该停止"，所以用 `break`

---

## 六、总结

OpenCode 的双层循环结束机制体现了以下设计原则：

### 职责分离

- **外层循环**：决策何时结束整个任务
- **内层循环**：决策单次调用是否成功，是否需要重试

### 渐进式结束

- 从细粒度（工具调用）到粗粒度（任务完成）
- 内层可以多次重试，外层才决定终止

### 优雅降级

- 可重试错误自动重试
- 不可重试错误立即终止
- 用户可以随时中断

### 清晰的状态传递

- 内层返回 "continue"/"stop"/"compact"
- 外层根据返回值决定下一步

这种设计使得 OpenCode 的 Agent 执行流程既**可靠**（自动重试），又**灵活**（随时中断），同时保持了**代码的可读性**（逻辑清晰）。
