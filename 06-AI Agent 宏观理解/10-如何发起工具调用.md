# 发起工具调用

AI Agent 通过 AI SDK 的 tool 函数包装工具定义

---

## 工具注册

ToolRegistry 收集所有可用工具，包括内置工具和自定义工具

MCP 工具通过单独的 MCP.tools() 函数获取

---

## 工具解析

resolveTools 函数遍历所有注册的工具

---

## 工具包装

每个工具通过 AI SDK 的 tool() 函数包装，创建包含 execute 和 toModelOutput 等方法的配置对象

MCP 工具通过重写 execute 方法包装，添加插件钩子和输出格式化

execute 方法内部处理调用流程：

1. 创建 Tool.Context 上下文对象
2. 触发 tool.execute.before 插件钩子
3. 调用 item.execute() 执行实际工具
4. 触发 tool.execute.after 插件钩子
5. 返回执行结果

---

## AI 调用

AI SDK 的 streamText 函数发起请求，将所有工具配置传递给 AI 模型。整个调用过程分为准备、执行、响应三个阶段。

---

### 1. 调用准备阶段

#### 系统提示构建

```typescript
// src/session/llm.ts:57-82
const system = SystemPrompt.header(input.model.providerID)
system.push([
  // 优先使用 agent prompt，否则使用 provider prompt
  ...(input.agent.prompt ? [input.agent.prompt] : SystemPrompt.provider(input.model)),
  // 自定义 prompt
  ...input.system,
  // 用户消息中的自定义 prompt
  ...(input.user.system ? [input.user.system] : []),
].filter((x) => x).join("\n"))
```

系统提示分为两部分以优化缓存：
- **header**: 固定头部（模型提供商标识）
- **body**: 动态内容（agent prompt + 用户自定义）

#### 参数配置

通过多层合并构建最终参数：

```typescript
// src/session/llm.ts:87-93
const options = pipe(
  ProviderTransform.options(input.model, input.sessionID, provider.options), // 基础配置
  mergeDeep(small),           // 小模型优化选项
  mergeDeep(input.model.options),  // 模型特定选项
  mergeDeep(input.agent.options),  // agent 特定选项
  mergeDeep(variant),         // 模型变体选项
)
```

#### 工具权限过滤

```typescript
// src/session/llm.ts:202-209
const disabled = PermissionNext.disabled(
  Object.keys(input.tools),
  input.agent.permission
)
for (const tool of Object.keys(input.tools)) {
  if (input.user.tools?.[tool] === false || disabled.has(tool)) {
    delete input.tools[tool]  // 移除禁用工具
  }
}
```

---

### 2. AI SDK 调用阶段

#### streamText 核心配置

```typescript
// src/session/llm.ts:127-199
return streamText({
  // 模型配置
  model: wrapLanguageModel({
    model: language,
    middleware: [
      // 消息转换中间件
      { async transformParams(args) { /* ... */ } },
      // 推理提取中间件
      extractReasoningMiddleware({ tagName: "think", startWithReasoning: false }),
    ],
  }),

  // 工具配置
  tools: input.tools,
  activeTools: Object.keys(tools).filter((x) => x !== "invalid"),

  // 生成参数
  temperature: params.temperature,
  topP: params.topP,
  topK: params.topK,
  maxOutputTokens,

  // 控制信号
  abortSignal: input.abort,
  maxRetries: input.retries ?? 0,

  // 消息历史
  messages: [
    ...system.map((x) => ({ role: "system", content: x })),
    ...input.messages,
  ],

  // 工具调用错误修复
  async experimental_repairToolCall(failed) {
    // 自动修复大小写不匹配的工具名称
    const lower = failed.toolCall.toolName.toLowerCase()
    if (lower !== failed.toolCall.toolName && tools[lower]) {
      return { ...failed.toolCall, toolName: lower }
    }
    // 返回无效工具错误
    return {
      ...failed.toolCall,
      toolName: "invalid",
      input: JSON.stringify({
        tool: failed.toolCall.toolName,
        error: failed.error.message,
      }),
    }
  },
})
```

#### AI 模型的决策过程

AI 模型接收以下信息进行决策：

1. **系统提示**: 告知模型可用的工具及其用途
2. **消息历史**: 包含之前的对话和工具调用结果
3. **工具定义**: 每个工具的名称、描述和参数 schema
4. **当前任务**: 用户最新的输入

模型根据这些信息决定：
- 是否需要调用工具
- 调用哪个工具
- 传递什么参数
- 是否需要多个工具协作

---

### 3. 流式响应阶段

AI SDK 返回异步流 `stream.fullStream`，产生一系列事件：

#### 完整事件序列

```typescript
// src/session/processor.ts:54-250
for await (const value of stream.fullStream) {
  switch (value.type) {
    // === 阶段 1: 开始 ===
    case "start":
      // 标记 session 为忙碌状态
      SessionStatus.set(input.sessionID, { type: "busy" })
      break

    // === 阶段 2: 推理 ===
    case "reasoning-start":
      // 创建推理 part
      reasoningMap[value.id] = { type: "reasoning", text: "", /* ... */ }
      break

    case "reasoning-delta":
      // 增量更新推理文本
      reasoningMap[value.id].text += value.text
      await Session.updatePart({ part, delta: value.text })
      break

    case "reasoning-end":
      // 完成推理 part
      part.text = part.text.trimEnd()
      part.time = { ...part.time, end: Date.now() }
      await Session.updatePart(part)
      break

    // === 阶段 3: 工具调用 ===
    case "tool-input-start":
      // 创建待执行的工具 part
      const part = await Session.updatePart({
        type: "tool",
        tool: value.toolName,
        callID: value.id,
        state: {
          status: "pending",  // 待执行状态
          input: {},
          raw: "",
        },
      })
      toolcalls[value.id] = part
      break

    case "tool-input-delta":
      // 参数收集过程中的增量更新（当前未使用）
      break

    case "tool-input-end":
      // 参数收集完成（当前未使用）
      break

    case "tool-call": {
      // 参数收集完成，开始执行工具
      const match = toolcalls[value.toolCallId]
      if (match) {
        // 更新为运行状态
        await Session.updatePart({
          ...match,
          tool: value.toolName,
          state: {
            status: "running",  // 运行中状态
            input: value.input,
            time: { start: Date.now() },
          },
          metadata: value.providerMetadata,
        })

        // Doom Loop 检测
        const parts = await MessageV2.parts(input.assistantMessage.id)
        const lastThree = parts.slice(-DOOM_LOOP_THRESHOLD)  // 最近 3 次调用

        if (
          lastThree.length === DOOM_LOOP_THRESHOLD &&
          lastThree.every((p) =>
            p.type === "tool" &&
            p.tool === value.toolName &&
            JSON.stringify(p.state.input) === JSON.stringify(value.input)
          )
        ) {
          // 触发权限询问，防止死循环
          await PermissionNext.ask({
            permission: "doom_loop",
            patterns: [value.toolName],
            sessionID: input.assistantMessage.sessionID,
            metadata: { tool: value.toolName, input: value.input },
          })
        }
      }
      break
    }

    case "tool-result": {
      // 工具执行成功
      const match = toolcalls[value.toolCallId]
      if (match && match.state.status === "running") {
        await Session.updatePart({
          ...match,
          state: {
            status: "completed",  // 完成状态
            input: value.input,
            output: value.output.output,
            metadata: value.output.metadata,
            title: value.output.title,
            time: {
              start: match.state.time.start,
              end: Date.now(),
            },
            attachments: value.output.attachments,
          },
        })
        delete toolcalls[value.toolCallId]  // 移除跟踪
      }
      break
    }

    case "tool-error": {
      // 工具执行失败
      const match = toolcalls[value.toolCallId]
      if (match && match.state.status === "running") {
        await Session.updatePart({
          ...match,
          state: {
            status: "error",  // 错误状态
            input: value.input,
            error: (value.error as any).toString(),
            time: {
              start: match.state.time.start,
              end: Date.now(),
            },
          },
        })

        // 如果是权限拒绝错误，标记为阻塞
        if (value.error instanceof PermissionNext.RejectedError) {
          blocked = shouldBreak
        }
        delete toolcalls[value.toolCallId]
      }
      break
    }

    // === 阶段 4: 文本生成 ===
    case "text-delta":
      // 增量文本生成（省略）
      break

    case "text-end":
      // 文本生成完成（省略）
      break

    // === 阶段 5: 步骤边界 ===
    case "start-step":
      // 创建步骤开始快照
      snapshot = await Snapshot.track()
      await Session.updatePart({
        type: "step-start",
        snapshot,
      })
      break

    case "finish-step":
      // 记录步骤结束统计
      const usage = Session.getUsage({ model: input.model, usage: value.usage })
      input.assistantMessage.finish = value.finishReason
      input.assistantMessage.cost += usage.cost
      input.assistantMessage.tokens = usage.tokens
      await Session.updatePart({
        type: "step-finish",
        reason: value.finishReason,
        snapshot: await Snapshot.track(),
        tokens: usage.tokens,
        cost: usage.cost,
      })
      break

    // === 阶段 6: 完成 ===
    case "finish":
      // 整个请求完成
      input.assistantMessage.finish = value.finishReason
      break

    case "error":
      // 发生错误
      throw value.error
  }
}
```

---

### 4. 工具执行流程

当 `tool-call` 事件触发时，AI SDK 自动执行以下步骤：

#### 4.1 查找工具

AI SDK 根据 `toolName` 从 `tools` 对象中查找对应的工具配置。

#### 4.2 调用 execute 方法

```typescript
// 工具的 execute 方法签名
execute: {
  (args: ToolInput, options: {
    toolCallId: string
    abortSignal: AbortSignal
  }) => Promise<ToolOutput>
}
```

#### 4.3 执行流程

1. **参数验证**: 使用 Zod schema 验证输入参数
2. **创建上下文**: 构建 `Tool.Context` 对象
3. **触发前置钩子**: `tool.execute.before` 插件钩子
4. **执行工具**: 调用实际工具实现
5. **触发后置钩子**: `tool.execute.after` 插件钩子
6. **返回结果**: 将结果传递给 AI SDK

#### 4.4 结果转换

工具执行完成后，`toModelOutput` 方法将结果转换为模型可理解的格式：

```typescript
toModelOutput: (output: ToolOutput) => {
  return {
    output: string | object,      // 主要输出内容
    metadata?: Record<string, any>,  // 元数据
    title?: string,                // 结果标题
    attachments?: Attachment[]     // 附件
  }
}
```

---

### 5. 迭代循环

AI 模型根据工具执行结果决定下一步：

1. **继续调用**: 需要更多工具 → 发起新的 tool-call 事件
2. **生成文本**: 开始生成回复 → 发送 text-delta 事件
3. **完成任务**: 任务完成 → 发送 finish 事件

这个过程会持续循环，直到：
- AI 模型认为任务完成
- 遇到无法恢复的错误
- 用户主动中止（abortSignal）
- 触发 Doom Loop 保护机制

---

### 6. 高级特性

#### 6.1 Doom Loop 检测

防止 AI 陷入无限循环：

```typescript
// src/session/processor.ts:143-167
const DOOM_LOOP_THRESHOLD = 3  // 连续 3 次相同调用

// 检测条件：
// 1. 最近 3 次调用
// 2. 都是相同工具
// 3. 参数完全相同
// 4. 不是 pending 状态

// 触发行为：
// 1. 显示权限询问对话框
// 2. 用户可以选择：
//    - 允许继续（allow always）
//    - 拒绝（deny）- 终止循环
//    - 本次允许（allow once）
```

#### 6.2 工具名称自动修复

AI 模型可能使用错误的工具名称大小写：

```typescript
// src/session/llm.ts:133-152
async experimental_repairToolCall(failed) {
  // 示例：模型调用 "ReadFile" 但工具名称是 "readfile"
  const lower = failed.toolCall.toolName.toLowerCase()
  if (lower !== failed.toolCall.toolName && tools[lower]) {
    // 自动转换为小写
    return { ...failed.toolCall, toolName: lower }
  }
  // 如果工具不存在，返回 "invalid" 工具
  return { ...failed.toolCall, toolName: "invalid", input: /* ... */ }
}
```

#### 6.3 消息压缩

当消息历史过长时触发压缩（详见 `session/compaction.ts`）

#### 6.4 插件钩子

- `experimental.chat.system.transform`: 转换系统提示
- `chat.params`: 修改生成参数
- `tool.execute.before/after`: 工具执行前后处理

---

## 参数验证

Tool.define 包装的 execute 方法内部，先使用 parameters.parse() 验证参数

验证通过后再调用实际实现，验证失败时抛出错误

---

## 状态更新

工具调用分为多个阶段，状态依次更新：

1. tool-input-start: 创建 part，状态为 pending
2. tool-call: 状态更新为 running，开始执行工具
3. tool-result/tool-error: 执行完成后，状态更新为 completed 或 error

---

## 上下文传递

Tool.Context 提供关键信息：sessionID、messageID、callID、abort 信号和权限请求方法
