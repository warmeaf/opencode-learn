# æµå¼è¾“å‡ºå¤„ç†æœºåˆ¶

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜ OpenCode å¦‚ä½•å¤„ç†å¤§è¯­è¨€æ¨¡å‹çš„æµå¼è¾“å‡ºï¼ŒåŒ…æ‹¬ä½•æ—¶è°ƒç”¨ LLMã€å¦‚ä½•å¤„ç†ä¸å®Œæ•´æ•°æ®ã€å®æ—¶ä¿å­˜æœºåˆ¶ç­‰ã€‚

## ä¸€ã€LLMçš„è°ƒç”¨æ—¶æœº

### è°ƒç”¨ä½ç½®

å¤§è¯­è¨€æ¨¡å‹åœ¨**å†…å±‚å¾ªç¯çš„å…¥å£**å¤„è¢«è°ƒç”¨ï¼š

```typescript
// packages/opencode/src/session/processor.ts:52
const stream = await LLM.stream(streamInput)
```

### å®Œæ•´è°ƒç”¨æµç¨‹

```
å¤–å±‚å¾ªç¯ (packages/opencode/src/session/prompt.ts:257)
  â”‚
  â”œâ”€ æ¯æ¬¡è¿­ä»£å¼€å§‹æ—¶æ£€æŸ¥ï¼š
  â”‚   â”œâ”€ abort.aborted? â†’ å¦‚æœtrueï¼Œé€€å‡ºå¤–å±‚å¾ªç¯
  â”‚   â”œâ”€ æ˜¯å¦æœ‰pendingçš„subtask? â†’ å¦‚æœæœ‰ï¼Œæ‰§è¡Œsubtaskï¼Œcontinue
  â”‚   â”œâ”€ æ˜¯å¦éœ€è¦compaction? â†’ å¦‚æœéœ€è¦ï¼Œæ‰§è¡Œcompactionï¼Œcontinue
  â”‚   â””â”€ æœ€åçš„assistantæ¶ˆæ¯çŠ¶æ€åˆ¤æ–­ï¼š
  â”‚       â”œâ”€ finishæ˜¯"tool-calls"æˆ–"unknown"? â†’ ç»§ç»­è°ƒç”¨LLM
  â”‚       â”œâ”€ lastUser.id >= lastAssistant.id? â†’ ç»§ç»­è°ƒç”¨LLMï¼ˆæ— assistantæ¶ˆæ¯ï¼‰
  â”‚       â””â”€ å…¶ä»–finishçŠ¶æ€ â†’ breakï¼Œé€€å‡ºå¤–å±‚å¾ªç¯
  â”‚
  â”œâ”€ é€šè¿‡ä»¥ä¸Šæ£€æŸ¥ï¼Œå‡†å¤‡è°ƒç”¨LLM
  â”‚
  â”œâ”€ åˆ›å»º SessionProcessor (prompt.ts:517)
  â”‚
  â”œâ”€ å‡†å¤‡è°ƒç”¨å‚æ•°
  â”‚   â”œâ”€ å‡†å¤‡ system prompts
  â”‚   â”œâ”€ æ„å»º messagesï¼ˆå†å²æ¶ˆæ¯ï¼‰
  â”‚   â”œâ”€ å‡†å¤‡ tools
  â”‚   â””â”€ ç¡®å®š model
  â”‚
  â””â”€ è°ƒç”¨ processor.process() â†’ è¿›å…¥å†…å±‚å¾ªç¯
      â”‚
      â”œâ”€ while(true)å¾ªç¯å¼€å§‹
      â”‚   â”‚
      â”‚   â”œâ”€ LLM.stream(streamInput) â† è°ƒç”¨LLM
      â”‚   â”‚
      â”‚   â”œâ”€ for await (const value of stream.fullStream)
      â”‚   â”‚   â”œâ”€ input.abort.throwIfAborted() â†’ æ£€æŸ¥abort
      â”‚   â”‚   â””â”€ å¤„ç†æµå¼äº‹ä»¶
      â”‚   â”‚
      â”‚   â”œâ”€ catch (é”™è¯¯)
      â”‚   â”‚   â”œâ”€ å¯é‡è¯•? â†’ delayåcontinueï¼Œå†æ¬¡è°ƒç”¨LLM
      â”‚   â”‚   â””â”€ ä¸å¯é‡è¯•? â†’ è®¾ç½®errorï¼Œreturn "stop"
      â”‚   â”‚
      â”‚   â”œâ”€ æ ¹æ®çŠ¶æ€å†³å®šæ˜¯å¦ç»§ç»­while(true)
      â”‚   â”‚   â”œâ”€ needsCompaction? â†’ return "compact"
      â”‚   â”‚   â”œâ”€ blocked? â†’ return "stop"
      â”‚   â”‚   â”œâ”€ error? â†’ return "stop"
      â”‚   â”‚   â””â”€ å…¶ä»– â†’ return "continue"
      â”‚   â”‚
      â”‚   â””â”€ å¾ªç¯ç»“æŸ
      â”‚
      â””â”€ è¿”å›åˆ°å¤–å±‚å¾ªç¯
          â”œâ”€ "stop"? â†’ breakï¼Œé€€å‡ºå¤–å±‚å¾ªç¯
          â”œâ”€ "compact"? â†’ æ‰§è¡Œcompactionï¼Œcontinue
          â””â”€ "continue"? â†’ continueï¼Œè¿›å…¥ä¸‹ä¸€æ¬¡è¿­ä»£
```

### è§¦å‘æ¡ä»¶

å¤–å±‚å¾ªç¯ä¼šåœ¨ä»¥ä¸‹æ¡ä»¶æ»¡è¶³æ—¶è°ƒç”¨LLMï¼š

**æ¡ä»¶1ï¼šå¾ªç¯ç»§ç»­æ¡ä»¶**ï¼ˆprompt.ts:294-301ï¼‰

- æœ€åçš„assistantæ¶ˆæ¯çš„finishçŠ¶æ€æ˜¯**"tool-calls"**æˆ–**"unknown"**
  - "tool-calls"ï¼šLLMè°ƒç”¨äº†å·¥å…·ï¼Œéœ€è¦æ‰§è¡Œå·¥å…·åç»§ç»­
  - "unknown"ï¼šçŠ¶æ€æœªçŸ¥ï¼Œéœ€è¦ç»§ç»­å¤„ç†
- æˆ–è€…æ²¡æœ‰å·²å®Œæˆçš„assistantæ¶ˆæ¯ï¼ˆlastUser.id >= lastAssistant.idï¼‰

**æ¡ä»¶2ï¼šæ— pendingä»»åŠ¡**

- æ²¡æœ‰å¾…å¤„ç†çš„subtaskï¼ˆprompt.ts:318ï¼‰
- æ²¡æœ‰éœ€è¦è‡ªåŠ¨æ‰§è¡Œçš„compactionï¼ˆprompt.ts:493ï¼‰

**æ¡ä»¶3ï¼šSessionæœªè¢«å–æ¶ˆ**ï¼ˆprompt.ts:273ï¼‰

- abortä¿¡å·æœªè¢«è§¦å‘

### ä¸ä¼šè°ƒç”¨LLMçš„æƒ…å†µ

å¤–å±‚å¾ªç¯åœ¨ä»¥ä¸‹æƒ…å†µä¸‹ä¼š**é€€å‡º**æˆ–**è·³è¿‡**LLMè°ƒç”¨ï¼š

**æƒ…å†µ1ï¼šæ­£å¸¸çš„å¯¹è¯ç»“æŸ**

- æœ€åçš„assistantæ¶ˆæ¯å·²å®Œæˆï¼Œä¸”finishçŠ¶æ€ä¸æ˜¯"tool-calls"æˆ–"unknown"
  - ä¾‹å¦‚ï¼š"stop"ï¼ˆæ­£å¸¸åœæ­¢ï¼‰ã€"length"ï¼ˆè¾¾åˆ°æœ€å¤§é•¿åº¦ï¼‰ã€"content_filter"ï¼ˆå†…å®¹è¿‡æ»¤ï¼‰ç­‰
  - ä¸”lastUser.id < lastAssistant.idï¼ˆè¯´æ˜assistantæ¶ˆæ¯æ˜¯æ–°ç”Ÿæˆçš„ï¼‰
- æ­¤æ—¶å¤–å±‚å¾ªç¯ä¼šbreakï¼Œé€€å‡ºæ•´ä¸ªå¾ªç¯ï¼ˆprompt.ts:294-301ï¼‰

**æƒ…å†µ2ï¼šå­˜åœ¨pendingçš„subtask**

- ç›´æ¥æ‰§è¡Œsubtaskï¼Œä¸è°ƒç”¨LLMï¼ˆprompt.ts:318-507ï¼‰

**æƒ…å†µ3ï¼šéœ€è¦æ‰§è¡Œcompaction**

- æ‰§è¡Œcompactionåcontinueï¼Œä¸è°ƒç”¨LLMï¼ˆprompt.ts:493-506ï¼‰

**æƒ…å†µ4ï¼šSessionè¢«å–æ¶ˆ**

- abortä¿¡å·è§¦å‘ï¼Œå¤–å±‚å¾ªç¯é€€å‡ºï¼ˆprompt.ts:273ï¼‰
- å†…å±‚å¾ªç¯ä¸­è°ƒç”¨abort.throwIfAborted()ï¼ŒæŠ›å‡ºå¼‚å¸¸ï¼ˆprocessor.ts:55ï¼‰

### LLMè°ƒç”¨çš„é«˜çº§ç‰¹æ€§

**1. å†…å±‚å¾ªç¯çš„while(true)æœºåˆ¶**ï¼ˆprocessor.ts:48-397ï¼‰

`processor.process()`æ–¹æ³•å†…éƒ¨ä½¿ç”¨`while(true)`å¾ªç¯ï¼Œè¿™æ„å‘³ç€åœ¨ä¸€æ¬¡`processor.process()`è°ƒç”¨ä¸­ï¼ŒLLMå¯èƒ½è¢«å¤šæ¬¡è°ƒç”¨ï¼š

```typescript
async process(streamInput: LLM.StreamInput) {
  while (true) {
    try {
      const stream = await LLM.stream(streamInput)
      // å¤„ç†æµå¼è¾“å‡º...

    } catch (e: any) {
      // é”™è¯¯å¤„ç†å’Œé‡è¯•
      const retry = SessionRetry.retryable(error)
      if (retry !== undefined) {
        attempt++
        const delay = SessionRetry.delay(attempt, error.name === "APIError" ? error : undefined)
        await SessionRetry.sleep(delay, input.abort).catch(() => {})
        continue  // â† é‡è¯•ï¼Œå†æ¬¡è°ƒç”¨LLM
      }
      // ä¸å¯é‡è¯•çš„é”™è¯¯ï¼Œé€€å‡ºå¾ªç¯
      input.assistantMessage.error = error
      return "stop"
    }

    // æ­£å¸¸ç»“æŸï¼Œæ ¹æ®çŠ¶æ€å†³å®šæ˜¯å¦ç»§ç»­
    if (needsCompaction) return "compact"
    if (blocked) return "stop"
    if (input.assistantMessage.error) return "stop"
    return "continue"
  }
}
```

**å…³é”®ç‚¹**ï¼š

- LLMè°ƒç”¨åœ¨while(true)å¾ªç¯å†…ï¼ˆç¬¬52è¡Œï¼‰
- å¦‚æœå‘ç”Ÿå¯é‡è¯•é”™è¯¯ï¼Œä¼šå»¶è¿Ÿåé‡è¯•ï¼Œå†æ¬¡è°ƒç”¨LLM
- åªæœ‰å½“è¿”å›"stop"æˆ–"compact"æ—¶ï¼Œæ‰ä¼šé€€å‡ºwhile(true)å¾ªç¯

**2. é”™è¯¯é‡è¯•é€»è¾‘**ï¼ˆprocessor.ts:335-359ï¼‰

å½“LLMè°ƒç”¨å¤±è´¥æ—¶ï¼Œä¼šè¿›è¡Œä»¥ä¸‹å¤„ç†ï¼š

```typescript
catch (e: any) {
  const error = MessageV2.fromError(e, { providerID: input.model.providerID })
  const retry = SessionRetry.retryable(error)
  if (retry !== undefined) {
    attempt++
    const delay = SessionRetry.delay(attempt, error.name === "APIError" ? error : undefined)
    SessionStatus.set(input.sessionID, {
      type: "retry",
      attempt,
      message: retry,
      next: Date.now() + delay,
    })
    await SessionRetry.sleep(delay, input.abort).catch(() => {})
    continue  // â† é‡è¯•
  }
  // ä¸å¯é‡è¯•çš„é”™è¯¯
  input.assistantMessage.error = error
  Bus.publish(Session.Event.Error, {
    sessionID: input.assistantMessage.sessionID,
    error: input.assistantMessage.error,
  })
}
```

**é‡è¯•æ¡ä»¶**ï¼š

- é”™è¯¯æ˜¯å¯é‡è¯•çš„ï¼ˆ`SessionRetry.retryable(error)`è¿”å›éundefinedï¼‰
- retryæ¬¡æ•°ä¼šé€’å¢
- å»¶è¿Ÿæ—¶é—´ä¼šæ ¹æ®attemptæ¬¡æ•°å’Œé”™è¯¯ç±»å‹è®¡ç®—
- å¦‚æœåœ¨ç­‰å¾…æœŸé—´abortï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸

**3. abortçš„ä¸¤ç§å¤„ç†æ–¹å¼**

abortä¿¡å·ä¼šåœ¨ä¸¤ä¸ªå±‚æ¬¡è¢«å¤„ç†ï¼š

**å¤–å±‚å¾ªç¯**ï¼ˆprompt.ts:273ï¼‰ï¼š

```typescript
while (true) {
  if (abort.aborted) break // ç›´æ¥é€€å‡ºå¤–å±‚å¾ªç¯
  // ...
}
```

**å†…å±‚å¾ªç¯**ï¼ˆprocessor.ts:55ï¼‰ï¼š

```typescript
for await (const value of stream.fullStream) {
  input.abort.throwIfAborted() // æŠ›å‡ºAbortErrorå¼‚å¸¸
  // ...
}
```

**åŒºåˆ«**ï¼š

- å¤–å±‚å¾ªç¯ï¼šåœ¨æ¯æ¬¡è¿­ä»£å¼€å§‹æ—¶æ£€æŸ¥ï¼Œå¦‚æœabortåˆ™é€€å‡ºæ•´ä¸ªå¤–å±‚å¾ªç¯
- å†…å±‚å¾ªç¯ï¼šåœ¨å¤„ç†æ¯ä¸ªæµå¼äº‹ä»¶æ—¶æ£€æŸ¥ï¼Œå¦‚æœabortåˆ™æŠ›å‡ºå¼‚å¸¸ï¼Œç”±catchå—å¤„ç†

## äºŒã€æµå¼æ•°æ®çš„æ¥æ”¶ä½ç½®

### åŒå±‚å¾ªç¯ä¸­çš„æµå¼æ•°æ®æµ

```
å¤–å±‚å¾ªç¯ (packages/opencode/src/session/prompt.ts:257)
  â”‚
  â”œâ”€ å†³ç­–ï¼šä½•æ—¶è°ƒç”¨ LLM
  â”‚  â””â”€ åˆ›å»º SessionProcessor
  â”‚
  â””â”€ è°ƒç”¨ processor.process() â†’ è¿›å…¥å†…å±‚å¾ªç¯

å†…å±‚å¾ªç¯ (packages/opencode/src/session/processor.ts:44)
  â”‚
  â”œâ”€ è°ƒç”¨ LLM.stream() è·å–æµ
  â”‚  â””â”€ const stream = await LLM.stream(streamInput)
  â”‚
  â””â”€ for await (const value of stream.fullStream)
     â””â”€ å¤„ç†æ¯ä¸ªæµå¼äº‹ä»¶ï¼ˆæ•°æ®å¯èƒ½ä¸å®Œæ•´ï¼‰
```

**å…³é”®ç‚¹**ï¼šæµå¼æ•°æ®åªåœ¨**å†…å±‚å¾ªç¯**ä¸­æ¥æ”¶ï¼Œå¤–å±‚å¾ªç¯åªè´Ÿè´£å†³ç­–å’Œä»»åŠ¡ç®¡ç†ã€‚

## ä¸‰ã€ä¸å®Œæ•´æ•°æ®çš„å¤„ç†ç­–ç•¥

### 1. æ–‡æœ¬è¾“å‡ºçš„å¢é‡ç´¯ç§¯

**äº‹ä»¶åºåˆ—**ï¼š

```
text-delta (1) â†’ text-delta (2) â†’ ... â†’ text-delta (N) â†’ text-end
```

**å¤„ç†ä»£ç **ï¼š

```typescript
case "text-start":
  currentText = {
    id: Identifier.ascending("part"),
    messageID: input.assistantMessage.id,
    sessionID: input.assistantMessage.sessionID,
    type: "text",
    text: "",
    time: {
      start: Date.now(),
    },
    metadata: value.providerMetadata,
  }
  break

case "text-delta":
  if (currentText) {
    currentText.text += value.text
    if (value.providerMetadata) currentText.metadata = value.providerMetadata
    if (currentText.text)
      await Session.updatePart({
        part: currentText,
        delta: value.text,
      })
  }
  break

case "text-end":
  // æ–‡æœ¬å®Œæ•´ï¼Œä¿å­˜æœ€ç»ˆçŠ¶æ€
  if (currentText) {
    currentText.text = currentText.text.trimEnd()
    currentText.time = {
      start: Date.now(),
      end: Date.now(),
    }
    if (value.providerMetadata) currentText.metadata = value.providerMetadata
    await Session.updatePart(currentText)
  }
  currentText = undefined
  break
```

**çŠ¶æ€è½¬æ¢**ï¼š

```
ç©ºæ–‡æœ¬ "" â†’ å¢é‡1 "Hel" â†’ å¢é‡2 "lo " â†’ å¢é‡3 "World" â†’ å®Œæ•´ "Hello World"
```

### 2. æ¨ç†è¿‡ç¨‹çš„å¢é‡ç´¯ç§¯

**äº‹ä»¶åºåˆ—**ï¼š

```
reasoning-start â†’ reasoning-delta (1) â†’ ... â†’ reasoning-delta (N) â†’ reasoning-end
```

**å¤„ç†ä»£ç **ï¼š

```typescript
case "reasoning-start":
  if (value.id in reasoningMap) {
    continue
  }
  reasoningMap[value.id] = {
    id: Identifier.ascending("part"),
    messageID: input.assistantMessage.id,
    sessionID: input.assistantMessage.sessionID,
    type: "reasoning",
    text: "",
    time: {
      start: Date.now(),
    },
    metadata: value.providerMetadata,
  }
  break

case "reasoning-delta":
  if (value.id in reasoningMap) {
    const part = reasoningMap[value.id]
    part.text += value.text
    if (value.providerMetadata) part.metadata = value.providerMetadata
    if (part.text) await Session.updatePart({ part, delta: value.text })
  }
  break

case "reasoning-end":
  // æ¨ç†å®Œæ•´ï¼Œä¿å­˜æœ€ç»ˆçŠ¶æ€
  if (value.id in reasoningMap) {
    const part = reasoningMap[value.id]
    part.text = part.text.trimEnd()
    part.time = {
      ...part.time,
      end: Date.now(),
    }
    if (value.providerMetadata) part.metadata = value.providerMetadata
    await Session.updatePart(part)
    delete reasoningMap[value.id]
  }
  break
```

### 3. å·¥å…·è°ƒç”¨çš„å¤šé˜¶æ®µçŠ¶æ€ç®¡ç†

**å®Œæ•´äº‹ä»¶åºåˆ—**ï¼š

```
tool-input-start â†’ tool-call â†’ tool-result
```

**çŠ¶æ€æœºè½¬æ¢**ï¼š

```typescript
case "tool-input-start":
  // é˜¶æ®µ 1: å·¥å…·è°ƒç”¨å¼€å§‹ï¼Œå‚æ•°ä¸ºç©º
  const part = await Session.updatePart({
    id: toolcalls[value.id]?.id ?? Identifier.ascending("part"),
    messageID: input.assistantMessage.id,
    type: "tool",
    tool: value.toolName,
    callID: value.id,
    state: {
      status: "pending",      // â† å¾…å®šçŠ¶æ€
      input: {},              // â† å‚æ•°ä¸ºç©º
      raw: "",                // â† åŸå§‹æ–‡æœ¬ä¸ºç©º
    },
  })
  toolcalls[value.id] = part as MessageV2.ToolPart
  break

case "tool-input-delta":
  // é˜¶æ®µ 2: å‚æ•°é€æ­¥ç´¯ç§¯ï¼ˆå¯é€‰äº‹ä»¶ï¼Œå½“å‰ç‰ˆæœ¬ä¸å¤„ç†ï¼‰
  // æ³¨æ„ï¼šåœ¨å½“å‰å®ç°ä¸­ï¼Œæ­¤äº‹ä»¶æ˜¯ç©ºå¤„ç†ï¼Œç›´æ¥è·³è¿‡
  break

case "tool-call":
  // é˜¶æ®µ 3: å‚æ•°å®Œæ•´ï¼Œæ‰§è¡Œå·¥å…·
  const match = toolcalls[value.toolCallId]
  if (match) {
    await Session.updatePart({
      ...match,
      tool: value.toolName,
      state: {
        status: "running",      // â† è¿è¡Œä¸­çŠ¶æ€
        input: value.input,     // â† å®Œæ•´å‚æ•°å·²è§£æ
        time: {
          start: Date.now(),
        },
      },
      metadata: value.providerMetadata,
    })

    // Doom Loop æ£€æµ‹
    const parts = await MessageV2.parts(input.assistantMessage.id)
    const lastThree = parts.slice(-3)

    if (
      lastThree.length === 3 &&
      lastThree.every(
        (p) =>
          p.type === "tool" &&
          p.tool === value.toolName &&
          p.state.status !== "pending" &&
          JSON.stringify(p.state.input) === JSON.stringify(value.input),
      )
    ) {
      // è§¦å‘è­¦å‘Š
      await PermissionNext.ask({
        permission: "doom_loop",
        patterns: [value.toolName],
        sessionID: input.assistantMessage.sessionID,
        metadata: { tool: value.toolName, input: value.input },
        always: [value.toolName],
        ruleset: agent.permission,
      })
    }
  }
  break

          case "tool-result":
            // å·¥å…·æ‰§è¡Œç»“æœï¼ˆçŠ¶æ€å®Œæˆï¼‰
            const match = toolcalls[value.toolCallId]
            if (match && match.state.status === "running") {
              await Session.updatePart({
                ...match,
                state: {
                  status: "completed",
                  input: value.input,
                  output: value.output.output,
                  metadata: value.output.metadata,
                  title: value.output.title,
                  time: {
                    start: match.state.time.start,
                    end: Date.now(),
                  },
                  attachments: value.output.attachments,
                },
              })
              delete toolcalls[value.toolCallId]
            }
            break
```

**çŠ¶æ€è½¬æ¢å›¾**ï¼š

```
pending (tool-input-start)
    â†“ [å‚æ•°è§£æå®Œæˆ]
    â†“
running (tool-call)
    â†“ [å·¥å…·æ‰§è¡Œä¸­]
    â†“
completed (tool-result)
    â†“ [ä¿å­˜ç»“æœï¼Œä» toolcalls ç§»é™¤]
    â†“
ä» UI/å†…å­˜ä¸­åˆ é™¤
```

## å››ã€ä¸å®Œæ•´æ•°æ®çš„å¤„ç†æœºåˆ¶å¯¹æ¯”

| æ•°æ®ç±»å‹     | äº‹ä»¶ç±»å‹           | ä¸å®Œæ•´ç‰¹å¾ | å¤„ç†æ–¹å¼                      | å­˜å‚¨ä½ç½®                 |
| ------------ | ------------------ | ---------- | ----------------------------- | ------------------------ |
| **æ–‡æœ¬**     | `text-delta`       | éƒ¨åˆ†å­—ç¬¦   | `text += delta` + å®æ—¶ä¿å­˜    | MessagePart.text         |
| **æ¨ç†**     | `reasoning-delta`  | éƒ¨åˆ†å†…å®¹   | `text += delta` + å…ƒæ•°æ®      | MessagePart.text         |
| **å·¥å…·å‚æ•°** | `tool-input-start` | å‚æ•°ä¸ºç©º   | åˆ›å»º pending çŠ¶æ€ï¼Œ`raw = ""` | MessagePart.state.raw    |
| **å·¥å…·è°ƒç”¨** | `tool-call`        | å‚æ•°å®Œæ•´   | è§£æ input + æ‰§è¡Œ             | MessagePart.state.input  |
| **å·¥å…·ç»“æœ** | `tool-result`      | æ‰§è¡Œå®Œæˆ   | ä¿å­˜ output + æ—¶é—´æˆ³          | MessagePart.state.output |

## äº”ã€å®æ—¶ä¿å­˜çš„ UI æ˜¾ç¤ºæœºåˆ¶

### 1. æ•°æ®æµå‘

```
LLM æµå¼è¾“å‡º
    â†“
for await (const value of stream.fullStream)
    â†“
Session.updatePart({ part, delta: value.text })
    â†“
æ•°æ®åº“æ›´æ–° + å‘å¸ƒäº‹ä»¶ (Bus.publish)
    â†“
UI ç›‘å¬äº‹ä»¶ â†’ å®æ—¶æ¸²æŸ“
```

### 2. ç”¨æˆ·çœ‹åˆ°çš„æ•ˆæœ

**åœºæ™¯ï¼šLLM è°ƒç”¨ `read` å·¥å…·è¯»å–æ–‡ä»¶**

| æ—¶é—´ | UI æ˜¾ç¤º                         | æ•°æ®çŠ¶æ€                             |
| ---- | ------------------------------- | ------------------------------------ |
| T0   | æ—                               | åˆå§‹çŠ¶æ€                             |
| T1   | `ğŸ” read(file.ts) [pending...]` | `tool-input-start`ï¼Œstatus = pending |
| T2   | `ğŸ” read(file.ts) [running...]` | `tool-call`ï¼Œstatus = running        |
| T3   | `âœ… read(file.ts) [completed]`  | `tool-result`ï¼Œstatus = completed    |

**åœºæ™¯ï¼šLLM ç”Ÿæˆæ–‡æœ¬å›å¤**

| æ—¶é—´ | UI æ˜¾ç¤º | æ•°æ®çŠ¶æ€                       |
| ---- | ------- | ------------------------------ |
| T0   | æ—       | åˆå§‹çŠ¶æ€                       |
| T1   | `H`     | `text-delta("H")`              |
| T2   | `He`    | `text-delta("e")`              |
| T3   | `Hel`   | `text-delta("l")`              |
| T4   | `Hell`  | `text-delta("l")`              |
| T5   | `Hello` | `text-delta("o")` + `text-end` |

### 3. ä¸ºä»€ä¹ˆéœ€è¦å®æ—¶ä¿å­˜ï¼Ÿ

1. **ç”¨æˆ·ä½“éªŒ**ï¼šç”¨æˆ·çœ‹åˆ°"æ­£åœ¨æ€è€ƒ"æˆ–"æ­£åœ¨è°ƒç”¨å·¥å…·"çš„å®æ—¶è¿›åº¦ï¼Œè€Œä¸æ˜¯ç™½å±
2. **é”™è¯¯æ¢å¤**ï¼šå¦‚æœè¿›ç¨‹å´©æºƒï¼Œå·²ç»å¤„ç†çš„éƒ¨åˆ†æ•°æ®ä¸ä¼šä¸¢å¤±
3. **å¤šç«¯åŒæ­¥**ï¼šå¤šä¸ªå®¢æˆ·ç«¯å¯ä»¥å®æ—¶çœ‹åˆ°ç›¸åŒçš„è¿›åº¦
4. **è°ƒè¯•ä¾¿åˆ©**ï¼šå¯ä»¥æŸ¥çœ‹æ¯ä¸ªäº‹ä»¶çš„æ‰§è¡Œæ—¶é—´æˆ³å’ŒçŠ¶æ€

## å…­ã€å®Œæ•´çš„äº‹ä»¶å¤„ç†æµç¨‹

```typescript
async process(streamInput: LLM.StreamInput) {
  const toolcalls: Record<string, MessageV2.ToolPart> = {}
  let blocked = false
  let attempt = 0

  while (true) {
    try {
      let currentText: MessageV2.TextPart | undefined
      let reasoningMap: Record<string, MessageV2.ReasoningPart> = {}

      // è°ƒç”¨ LLM æµå¼æ¥å£
      const stream = await LLM.stream(streamInput)

      // å¤„ç† LLM çš„æµå¼è¾“å‡º
      for await (const value of stream.fullStream) {
        input.abort.throwIfAborted()

        switch (value.type) {
          case "start":
            SessionStatus.set(input.sessionID, { type: "busy" })
            break

          case "reasoning-start":
            // æ¨ç†å¼€å§‹
            if (value.id in reasoningMap) {
              continue
            }
            reasoningMap[value.id] = {
              id: Identifier.ascending("part"),
              messageID: input.assistantMessage.id,
              sessionID: input.assistantMessage.sessionID,
              type: "reasoning",
              text: "",
              time: {
                start: Date.now(),
              },
              metadata: value.providerMetadata,
            }
            break

          case "reasoning-delta":
            // æ¨ç†å†…å®¹å¢é‡
            if (value.id in reasoningMap) {
              const part = reasoningMap[value.id]
              part.text += value.text
              if (value.providerMetadata) part.metadata = value.providerMetadata
              if (part.text) await Session.updatePart({ part, delta: value.text })
            }
            break

          case "reasoning-end":
            // æ¨ç†ç»“æŸ
            if (value.id in reasoningMap) {
              const part = reasoningMap[value.id]
              part.text = part.text.trimEnd()
              part.time = {
                ...part.time,
                end: Date.now(),
              }
              if (value.providerMetadata) part.metadata = value.providerMetadata
              await Session.updatePart(part)
              delete reasoningMap[value.id]
            }
            break

          case "text-start":
            // æ–‡æœ¬å¼€å§‹
            currentText = {
              id: Identifier.ascending("part"),
              messageID: input.assistantMessage.id,
              sessionID: input.assistantMessage.sessionID,
              type: "text",
              text: "",
              time: {
                start: Date.now(),
              },
              metadata: value.providerMetadata,
            }
            break

          case "text-delta":
            // æ–‡æœ¬å¢é‡
            if (currentText) {
              currentText.text += value.text
              if (value.providerMetadata) currentText.metadata = value.providerMetadata
              if (currentText.text)
                await Session.updatePart({ part: currentText, delta: value.text })
            }
            break

          case "text-end":
            // æ–‡æœ¬ç»“æŸ
            if (currentText) {
              currentText.text = currentText.text.trimEnd()
              currentText.time = {
                start: Date.now(),
                end: Date.now(),
              }
              if (value.providerMetadata) currentText.metadata = value.providerMetadata
              await Session.updatePart(currentText)
            }
            currentText = undefined
            break

          case "tool-input-start":
            // å·¥å…·è°ƒç”¨å¼€å§‹ï¼ˆå‚æ•°ä¸å®Œæ•´ï¼‰
            const part = await Session.updatePart({
              id: toolcalls[value.id]?.id ?? Identifier.ascending("part"),
              messageID: input.assistantMessage.id,
              type: "tool",
              tool: value.toolName,
              callID: value.id,
              state: {
                status: "pending",
                input: {},
                raw: "",
              },
            })
            toolcalls[value.id] = part as MessageV2.ToolPart
            break

          case "tool-call":
            // å·¥å…·è°ƒç”¨æ‰§è¡Œï¼ˆå‚æ•°å®Œæ•´ï¼‰
            const match = toolcalls[value.toolCallId]
            if (match) {
              const part = await Session.updatePart({
                ...match,
                tool: value.toolName,
                state: {
                  status: "running",
                  input: value.input,
                  time: { start: Date.now() },
                },
                metadata: value.providerMetadata,
              })
              toolcalls[value.toolCallId] = part as MessageV2.ToolPart
            }
            break

          case "tool-result":
            // å·¥å…·æ‰§è¡Œç»“æœï¼ˆçŠ¶æ€å®Œæˆï¼‰
            const match = toolcalls[value.toolCallId]
            if (match) {
              await Session.updatePart({
                ...match,
                state: {
                  status: "completed",
                  input: value.input,
                  output: value.output.output,
                  title: value.output.title,
                  time: { start: match.state.time.start, end: Date.now() },
                },
              })
            }
            delete toolcalls[value.toolCallId]
            break

          case "finish":
            // æµå¼è¾“å‡ºç»“æŸ
            break
        }
      }
    } catch (e: any) {
      // é”™è¯¯å¤„ç†å’Œé‡è¯•
      log.error("process", { error: e, stack: JSON.stringify(e.stack) })
      const error = MessageV2.fromError(e, { providerID: input.model.providerID })
      const retry = SessionRetry.retryable(error)
      if (retry !== undefined) {
        attempt++
        const delay = SessionRetry.delay(attempt, error.name === "APIError" ? error : undefined)
        SessionStatus.set(input.sessionID, {
          type: "retry",
          attempt,
          message: retry,
          next: Date.now() + delay,
        })
        await SessionRetry.sleep(delay, input.abort).catch(() => {})
        continue
      }
      input.assistantMessage.error = error
      Bus.publish(Session.Event.Error, {
        sessionID: input.assistantMessage.sessionID,
        error: input.assistantMessage.error,
      })
    }

    // è¿”å›æ˜¯å¦ç»§ç»­å¾ªç¯
    if (needsCompaction) return "compact"
    if (blocked) return "stop"
    if (input.assistantMessage.error) return "stop"
    return "continue"
  }
}
```

## ä¸ƒã€æ ¸å¿ƒè®¾è®¡åŸåˆ™

### 1. å¢é‡å¤„ç†

- **åŸåˆ™**ï¼šæ¥äº†ä¸€ä¸ªäº‹ä»¶å¤„ç†ä¸€ä¸ªï¼Œä¸ç­‰å¾…å®Œæ•´æ•°æ®
- **ä¼˜åŠ¿**ï¼šå®æ—¶åé¦ˆï¼Œç”¨æˆ·ä½“éªŒå¥½

### 2. çŠ¶æ€é©±åŠ¨

- **åŸåˆ™**ï¼šé€šè¿‡çŠ¶æ€æœºç®¡ç†æ•°æ®ä»"ä¸å®Œæ•´"åˆ°"å®Œæ•´"çš„è½¬æ¢
- **ä¼˜åŠ¿**ï¼šå¯è¿½è¸ªã€å¯æ¢å¤ã€å¯è°ƒè¯•

### 3. å®æ—¶ä¿å­˜

- **åŸåˆ™**ï¼šæ¯æ¬¡å¢é‡éƒ½åŒæ­¥åˆ°æ•°æ®åº“ï¼Œä¸ç­‰åˆ°å®Œæ•´æ‰ä¿å­˜
- **ä¼˜åŠ¿**ï¼šæ•°æ®å®‰å…¨ï¼Œæ”¯æŒå¤šç«¯åŒæ­¥

### 4. äº‹ä»¶é©±åŠ¨

- **åŸåˆ™**ï¼šå“åº”å¼å¤„ç†ï¼Œæ¯ä¸ªäº‹ä»¶è§¦å‘ç›¸åº”åŠ¨ä½œ
- **ä¼˜åŠ¿**ï¼šè§£è€¦ï¼Œå¯æ‰©å±•

## å…«ã€å¸¸è§é—®é¢˜

### Q1: ä¸ºä»€ä¹ˆä¸ç­‰å¾…å®Œæ•´æ•°æ®å†å¤„ç†ï¼Ÿ

**A**: æµå¼è¾“å‡ºçš„æ ¸å¿ƒä»·å€¼åœ¨äº**å®æ—¶åé¦ˆ**ã€‚å¦‚æœç­‰å¾…å®Œæ•´æ•°æ®ï¼Œç”¨æˆ·ä¼šé•¿æ—¶é—´çœ‹åˆ°ç™½å±æˆ–åŠ è½½ä¸­ï¼Œä½“éªŒå¾ˆå·®ã€‚

### Q2: å¦‚æœç½‘ç»œä¸­æ–­ï¼Œå·²å¤„ç†çš„æ•°æ®ä¼šä¸¢å¤±å—ï¼Ÿ

**A**: ä¸ä¼šã€‚æ¯æ¬¡å¢é‡éƒ½é€šè¿‡ `Session.updatePart` ä¿å­˜åˆ°æ•°æ®åº“ï¼Œå·²å¤„ç†çš„éƒ¨åˆ†æ•°æ®ä¸ä¼šä¸¢å¤±ã€‚

### Q3: å¦‚ä½•çŸ¥é“å·¥å…·è°ƒç”¨æ˜¯å¦å®Œæ•´ï¼Ÿ

**A**: é€šè¿‡çŠ¶æ€æœºã€‚`tool-input-start` â†’ `tool-call` â†’ `tool-result`ï¼Œåªæœ‰æ”¶åˆ° `tool-result` æ‰ç®—å®Œæ•´ã€‚

### Q4: ä¸ºä»€ä¹ˆ `tool-input-delta` äº‹ä»¶ä¸å¤„ç†ï¼Ÿ

**A**: åœ¨å½“å‰å®ç°ä¸­ï¼Œ`tool-input-delta` äº‹ä»¶æ˜¯ç©ºå¤„ç†ã€‚å·¥å…·å‚æ•°åœ¨ `tool-call` äº‹ä»¶ä¸­ä¸€æ¬¡æ€§å®Œæ•´æ¥æ”¶ï¼Œè€Œä¸æ˜¯é€æ­¥ç´¯ç§¯ã€‚è¿™ä¸ªäº‹ä»¶ä¿ç•™æ˜¯ä¸ºäº†æœªæ¥çš„æ‰©å±•å¯èƒ½ã€‚

### Q5: ä¸ºä»€ä¹ˆéœ€è¦ `toolcalls` å¯¹è±¡ï¼Ÿ

**A**: å› ä¸ºæµå¼äº‹ä»¶æ˜¯æ— åºçš„ï¼Œå¯èƒ½æ”¶åˆ° `tool-call` ä½†è¿˜æ²¡æ”¶åˆ°å¯¹åº”çš„ `tool-input-start`ã€‚`toolcalls` å¯¹è±¡ç»´æŠ¤äº†å½“å‰å¾…å¤„ç†çš„å·¥å…·è°ƒç”¨æ˜ å°„ã€‚

### Q6: å¢é‡ç´¯ç§¯ä¼šä¸ä¼šæ€§èƒ½é—®é¢˜ï¼Ÿ

**A**: ä¸ä¼šã€‚å¢é‡æ˜¯å­—ç¬¦ä¸²æ‹¼æ¥ï¼Œæ—¶é—´å¤æ‚åº¦ O(n)ï¼Œä¸”æ¯æ¬¡å¢é‡éƒ½æ˜¯å°ç‰‡æ®µï¼ˆé€šå¸¸ 1-10 ä¸ª tokenï¼‰ï¼Œæ€§èƒ½å¼€é”€å¯å¿½ç•¥ã€‚

## ä¹ã€æ€»ç»“

OpenCode å¤„ç† LLM æµå¼è¾“å‡ºçš„æ ¸å¿ƒæœºåˆ¶ï¼š

1. **æ¥æ”¶ä½ç½®**ï¼šåœ¨å†…å±‚å¾ªç¯ä¸­é€šè¿‡ `for await (const value of stream.fullStream)` æ¥æ”¶
2. **å¤„ç†ç­–ç•¥**ï¼šå¢é‡ç´¯ç§¯ + çŠ¶æ€æœºç®¡ç†
3. **ä¿å­˜æœºåˆ¶**ï¼šæ¯æ¬¡å¢é‡éƒ½å®æ—¶ä¿å­˜åˆ°æ•°æ®åº“ï¼ŒUI å®æ—¶æ˜¾ç¤º
4. **çŠ¶æ€è½¬æ¢**ï¼špending â†’ running â†’ completedï¼ˆå·¥å…·è°ƒç”¨ï¼‰
5. **ç”¨æˆ·ä½“éªŒ**ï¼šå®æ—¶çœ‹åˆ°è¿›åº¦ï¼Œè€Œä¸æ˜¯ç­‰å¾…å®Œæ•´å“åº”

è¿™ç§è®¾è®¡ä½¿å¾— OpenCode èƒ½å¤Ÿæä¾›æµç•…ã€å¯é çš„ç”¨æˆ·ä½“éªŒï¼ŒåŒæ—¶ä¿è¯æ•°æ®çš„å®Œæ•´æ€§å’Œå¯æ¢å¤æ€§ã€‚
