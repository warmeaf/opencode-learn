# 工具发现与调用机制

## 概述

OpenCode 的工具系统是 AI Agent 执行任务的核心机制。AI 通过工具与文件系统、终端、网络等外部环境交互。本文档详细说明工具是如何被发现、注册和调用的。

## 一、有哪些工具可以调用

### 1.1 内置工具

OpenCode 内置了以下核心工具（按功能分类）：

#### 文件操作类

- **read**: 读取文件内容
- **write**: 写入新文件
- **edit**: 精确字符串替换编辑
- **glob**: 文件模式匹配搜索
- **grep**: 内容搜索

#### 终端执行类

- **bash**: 执行 shell 命令

#### 网络工具类

- **webfetch**: 获取 URL 内容
- **websearch**: 网络搜索（需要 opencode 或启用标志）
- **codesearch**: 代码搜索（需要 opencode 或启用标志）

#### 任务管理类

- **task**: 启动子 agent 执行复杂任务
- **todowrite**: 创建待办事项列表
- **todoread**: 读取待办事项

#### 高级功能类

- **skill**: 加载技能获取专业指导
- **batch**: 批量编辑文件（实验性，需配置启用）
- **lsp**: 语言服务器协议支持（实验性，需配置启用）
- **invalid**: 无效工具占位符

#### 特殊工具（系统自动调用）

- **list**: 列出目录内容（仅在用户上传目录时系统自动调用，AI 不能主动调用）

### 1.2 插件工具

OpenCode 支持动态加载插件工具，来源包括：

- **本地自定义工具**: 项目目录 `tool/*.{js,ts}` 中的工具
- **插件系统**: 通过 `@opencode-ai/plugin` 插件提供的工具
- **MCP 服务器**: Model Context Protocol 服务器提供的工具

### 1.3 工具列表查看

所有可用工具的 ID 可以通过 `ToolRegistry.ids()` 获取：

```typescript
const toolIds = await ToolRegistry.ids()
// ["bash", "read", "edit", "glob", "grep", ...]
```

## 二、工具发现与注册机制

### 2.1 工具定义结构

每个工具都遵循 `Tool.Info` 接口定义（位于 `packages/opencode/src/tool/tool.ts`）：

```typescript
export interface Info<Parameters extends z.ZodType = z.ZodType, M extends Metadata = Metadata> {
  id: string // 工具唯一标识符
  init: (ctx?: InitContext) => Promise<{
    description: string // 工具描述（发送给 AI）
    parameters: Parameters // Zod 参数验证 schema
    execute(
      args: z.infer<Parameters>, // 执行参数
      ctx: Context, // 执行上下文
    ): Promise<{
      title: string
      metadata: M
      output: string
      attachments?: MessageV2.FilePart[]
    }>
    formatValidationError?(error: z.ZodError): string
  }>
}
```

### 2.2 工具注册流程

工具注册由 `ToolRegistry` 模块管理（位于 `packages/opencode/src/tool/registry.ts`）：

#### 步骤 1: 收集自定义工具

```typescript
export const state = Instance.state(async () => {
  const custom = [] as Tool.Info[]
  const glob = new Bun.Glob("tool/*.{js,ts}")

  // 扫描项目目录中的自定义工具
  for (const dir of await Config.directories()) {
    for await (const match of glob.scan({
      cwd: dir,
      absolute: true,
      followSymlinks: true,
      dot: true,
    })) {
      const namespace = path.basename(match, path.extname(match))
      const mod = await import(match)
      for (const [id, def] of Object.entries<ToolDefinition>(mod)) {
        custom.push(fromPlugin(id === "default" ? namespace : `${namespace}_${id}`, def))
      }
    }
  }

  // 扫描插件工具
  const plugins = await Plugin.list()
  for (const plugin of plugins) {
    for (const [id, def] of Object.entries(plugin.tool ?? {})) {
      custom.push(fromPlugin(id, def))
    }
  }

  return { custom }
})
```

#### 步骤 2: 组合所有工具

```typescript
async function all(): Promise<Tool.Info[]> {
  const custom = await state().then((x) => x.custom)
  const config = await Config.get()

  return [
    InvalidTool,
    BashTool,
    ReadTool,
    GlobTool,
    GrepTool,
    EditTool,
    WriteTool,
    TaskTool,
    WebFetchTool,
    TodoWriteTool,
    TodoReadTool,
    WebSearchTool,
    CodeSearchTool,
    SkillTool,
    ...(Flag.OPENCODE_EXPERIMENTAL_LSP_TOOL ? [LspTool] : []),
    ...(config.experimental?.batch_tool === true ? [BatchTool] : []),
    ...custom, // 自定义工具
  ]
}
```

#### 步骤 3: 根据提供者过滤和初始化

```typescript
export async function tools(providerID: string, agent?: Agent.Info) {
  const tools = await all()
  const result = await Promise.all(
    tools
      .filter((t) => {
        // 特定工具仅对特定提供者启用
        if (t.id === "codesearch" || t.id === "websearch") {
          return providerID === "opencode" || Flag.OPENCODE_ENABLE_EXA
        }
        return true
      })
      .map(async (t) => {
        using _ = log.time(t.id)
        return {
          id: t.id,
          ...(await t.init({ agent })), // 初始化工具
        }
      }),
  )
  return result
}
```

### 2.3 工具示例

#### Read 工具定义（简化）

```typescript
export const ReadTool = Tool.define("read", {
  description: "Reads a file from the local filesystem...",
  parameters: z.object({
    filePath: z.string().describe("The path to the file to read"),
    offset: z.coerce.number().optional(),
    limit: z.coerce.number().optional(),
  }),
  async execute(params, ctx) {
    // 执行逻辑
    const file = Bun.file(filepath)
    const content = await file.text()
    return {
      title: path.basename(filepath),
      output: content,
      metadata: {},
    }
  },
})
```

#### Bash 工具定义（简化）

> **注意**: 以下代码为简化示例，实际实现包含命令解析（使用 web-tree-sitter）、权限检查（external_directory 和 bash 权限）、输出截断、超时处理、中止信号处理等更多功能。完整实现请参考 `packages/opencode/src/tool/bash.ts`

```typescript
export const BashTool = Tool.define("bash", async () => {
  const shell = Shell.acceptable()

  return {
    description: `Executes a given bash command...`,
    parameters: z.object({
      command: z.string(),
      timeout: z.number().optional(),
      workdir: z.string().optional(),
      description: z.string(),
    }),
    async execute(params, ctx) {
      // 执行命令并返回结果
      const proc = spawn(params.command, { shell, cwd })
      // ... 处理输出
      return {
        title: params.description,
        output: output,
        metadata: {},
      }
    },
  }
})
```

## 三、AI 如何知道有哪些工具

### 3.1 系统提示词中的工具定义

OpenCode 通过系统提示词将工具信息传递给 AI。系统提示词文件位于 `packages/opencode/src/session/prompt/anthropic.txt`。

关键指令包括：

```
# Tool usage policy
- When doing file search, prefer to use the Task tool in order to reduce context usage.
- You should proactively use the Task tool with specialized agents when the task at hand matches the agent's description.
- When WebFetch returns a message about a redirect...
- You can call multiple tools in a single response...
- Use specialized tools instead of bash commands when possible...
```

### 3.2 工具 Schema 转换

在会话创建时，工具信息被转换为 AI 模型可以理解的格式：

```typescript
// packages/opencode/src/session/prompt.ts:659
for (const item of await ToolRegistry.tools(input.model.providerID)) {
  const schema = ProviderTransform.schema(input.model, z.toJSONSchema(item.parameters))
  tools[item.id] = tool({
    id: item.id,
    description: item.description,
    inputSchema: jsonSchema(schema as any),
    async execute(args, options) {
      const ctx = context(args, options)
      const result = await item.execute(args, ctx)
      return result
    },
  })
}
```

### 3.3 工具描述示例

每个工具都有详细的描述文件（`.txt`），例如：

#### read.txt

```
Reads a file from the local filesystem. You can access any file directly by using this tool.
Assume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.

Usage:
- The filePath parameter must be an absolute path, not a relative path
- By default, it reads up to 2000 lines starting from the beginning of the file
- You can optionally specify a line offset and limit...
```

#### edit.txt

```
Performs exact string replacements in files.

Usage:
- You must use your `Read` tool at least once in the conversation before editing.
- When editing text from Read tool output, ensure you preserve exact indentation...
- The edit will FAIL if `oldString` is not found in the file...
```

#### bash.txt

```
Executes a given bash command in a persistent shell session with optional timeout...

All commands run in ${directory} by default. Use the `workdir` parameter...

IMPORTANT: This tool is for terminal operations like git, npm, docker, etc.
DO NOT use it for file operations - use the specialized tools for this instead.
```

这些描述被作为 `description` 字段发送给 AI，帮助 AI 理解：

- 工具的用途
- 参数要求
- 使用场景
- 注意事项

## 四、AI 如何决定调用哪些工具

### 4.1 基于系统提示词的决策

系统提示词明确指导 AI 何时使用特定工具：

```
- Use specialized tools instead of bash commands when possible:
  - File search: Use Glob (NOT find or ls)
  - Content search: Use Grep (NOT grep or rg)
  - Read files: Use Read (NOT cat/head/tail)
  - Edit files: Use Edit (NOT sed/awk)
  - Write files: Use Write (NOT echo >/cat <<EOF)

- When the user asks about opencode features, use the WebFetch tool to gather information from OpenCode docs.

- You should proactively use the Task tool with specialized agents when the task at hand matches the agent's description.
```

### 4.2 基于工具描述的匹配

每个工具的 `description` 字段包含：

- 工具的核心功能说明
- 参数的详细描述（通过 Zod schema）
- 使用示例和注意事项

AI 通过这些信息判断工具是否适合当前任务。

### 4.3 基于工具权限的过滤

不同 Agent 有不同的工具权限：

```typescript
// packages/opencode/src/agent/agent.ts
explore: {
  permission: PermissionNext.fromConfig({
    "*": "deny", // 默认拒绝所有工具
    grep: "allow",
    glob: "allow",
    bash: "allow",
    webfetch: "allow",
    websearch: "allow",
    codesearch: "allow",
    read: "allow",
  }),
  description: `Fast agent specialized for exploring codebases...`
}
```

这意味着：

- **explore agent** 只能使用搜索和读取类工具（以及 bash 终端工具）
- **general agent** 被禁止使用 todowrite/todoread
- **build agent** 可以使用所有工具（默认 allow）

### 4.4 基于任务类型的自动选择

系统提示词提供了明确的场景指导：

```
<example>
user: Where are errors from the client handled?
assistant: [Uses the Task tool to find the files that handle client errors instead of using Glob or Grep directly]
</example>

<example>
user: What is the codebase structure?
assistant: [Uses the Task tool]
</example>
```

指导原则：

- **探索性任务**（"如何工作的"、"在哪里"）→ 使用 Task tool
- **具体查询**（读取特定文件、查找特定类）→ 直接使用 Read/Glob/Grep
- **终端操作** → 使用 Bash
- **编辑文件** → 先 Read，再 Edit
- **创建文件** → 使用 Write

## 五、工具调用流程

### 5.1 完整流程

```
1. 用户输入
   ↓
2. 系统提示词 + 工具列表（JSON Schema）发送给 AI
   ↓
3. AI 分析任务，选择合适的工具
   ↓
4. AI 生成工具调用请求（工具名称 + 参数）
   ↓
5. 工具参数验证（Zod schema）
   ↓
6. 执行权限检查（Permission system）
   ↓
7. 执行工具
   ↓
8. 返回结果给 AI
   ↓
9. AI 基于结果继续处理或调用下一个工具
```

### 5.2 参数验证

每个工具调用前都会进行参数验证：

```typescript
// packages/opencode/src/tool/tool.ts:54-69
execute = (args, ctx) => {
  try {
    toolInfo.parameters.parse(args)
  } catch (error) {
    if (error instanceof z.ZodError && toolInfo.formatValidationError) {
      throw new Error(toolInfo.formatValidationError(error), { cause: error })
    }
    throw new Error(
      `The ${id} tool was called with invalid arguments: ${error}.\nPlease rewrite the input so it satisfies the expected schema.`,
      { cause: error },
    )
  }
  return execute(args, ctx)
}
```

### 5.3 权限控制

工具执行前会检查权限：

```typescript
// packages/opencode/src/tool/read.ts:43-48
await ctx.ask({
  permission: "read",
  patterns: [filepath],
  always: ["*"],
  metadata: {},
})
```

权限级别：

- **allow**: 自动允许
- **deny**: 禁止调用
- **ask**: 询问用户

### 5.4 插件钩子

工具执行前后可以触发插件钩子：

```typescript
// packages/opencode/src/session/prompt.ts:667-687
await Plugin.trigger(
  "tool.execute.before",
  {
    tool: item.id,
    sessionID: ctx.sessionID,
    callID: ctx.callID,
  },
  { args },
)

const result = await item.execute(args, ctx)

await Plugin.trigger(
  "tool.execute.after",
  {
    tool: item.id,
    sessionID: ctx.sessionID,
    callID: ctx.callID,
  },
  result,
)
```

## 六、总结

### 关键要点

1. **工具来源多样**
   - 内置工具（13 个核心工具 + 2 个条件加载的实验性工具）
   - 项目自定义工具（tool/\*.ts）
   - 插件工具
   - MCP 服务器工具

2. **工具注册机制**
   - 扫描项目目录加载自定义工具
   - 扫描插件系统加载插件工具
   - 根据配置和标志过滤工具
   - 初始化工具并生成 schema

3. **AI 如何知道工具**
   - 系统提示词中的工具使用政策
   - 工具的描述字段（description）
   - 工具的参数 schema（JSON Schema）
   - Agent 的权限配置

4. **AI 如何选择工具**
   - 基于系统提示词的明确指导
   - 基于工具描述的功能匹配
   - 基于任务类型的场景判断
   - 基于权限配置的可用性

5. **工具调用流程**
   - 参数验证（Zod）
   - 权限检查（Permission system）
   - 实际执行
   - 插件钩子触发
   - 结果返回

### 设计原则

- **专用工具优先**: 有专用工具时优先使用，避免用 bash 重复实现
- **并行调用**: 独立操作应并行执行以提高效率
- **精确编辑**: Edit 工具要求精确匹配，避免模糊编辑
- **权限控制**: 不同 Agent 有不同权限，确保安全
- **可扩展性**: 支持自定义工具和插件，易于扩展

## 相关文件

- `packages/opencode/src/tool/tool.ts`: 工具接口定义
- `packages/opencode/src/tool/registry.ts`: 工具注册和管理
- `packages/opencode/src/session/prompt/anthropic.txt`: 系统提示词
- `packages/opencode/src/session/prompt.ts`: 会话提示和工具初始化
- `packages/opencode/src/agent/agent.ts`: Agent 权限配置
- `packages/opencode/src/tool/*.ts`: 各工具实现
- `packages/opencode/src/tool/*.txt`: 工具描述文件
