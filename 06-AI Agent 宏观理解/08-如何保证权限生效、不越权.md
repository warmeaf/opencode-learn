# 权限生效保证机制

AI Agent 的权限控制通过多层次防护实现，确保即使大语言模型"活着"也无法越过权限限制。

## 核心设计理念

权限控制不依赖 LLM 的"自律"，而是通过强制性的系统级约束来实现。LLM 只能调用系统允许它调用的工具，被禁用的工具根本不会出现在 LLM 的视野中。

---

## 三层防护机制

### 第一层：工具过滤

LLM 只能看到并调用系统明确提供的工具列表，被禁用的工具会在传给 LLM 前被移除。

**代码位置**：`packages/opencode/src/session/llm.ts:202-210`

```typescript
async function resolveTools(input: Pick<StreamInput, "tools" | "agent" | "user">) {
  const disabled = PermissionNext.disabled(Object.keys(input.tools), input.agent.permission)
  for (const tool of Object.keys(input.tools)) {
    if (input.user.tools?.[tool] === false || disabled.has(tool)) {
      delete input.tools[tool] // 从工具列表中删除
    }
  }
  return input.tools
}
```

**关键点**：

- 在调用 `streamText()` 之前执行
- 检查 Agent 的权限规则
- 被禁用的工具被直接删除
- LLM 根本看不到这些工具

**代码位置**：`packages/opencode/src/permission/next.ts:231-240`

```typescript
export function disabled(tools: string[], ruleset: Ruleset): Set<string> {
  const result = new Set<string>()
  for (const tool of tools) {
    const permission = EDIT_TOOLS.includes(tool) ? "edit" : tool
    if (evaluate(permission, "*", ruleset).action === "deny") {
      result.add(tool)
    }
  }
  return result
}
```

**示例**：

如果 `explore` Agent 的配置如下：

```typescript
explore: {
  permission: PermissionNext.merge(
    defaults,
    PermissionNext.fromConfig({
      "*": "deny",        // 默认拒绝所有工具
      grep: "allow",       // 只允许 grep
      glob: "allow",       // 只允许 glob
      list: "allow",       // 只允许 list
      bash: "allow",       // 只允许 bash
      webfetch: "allow",   // 只允许 webfetch
      websearch: "allow",  // 只允许 websearch
      codesearch: "allow",  // 只允许 codesearch
      read: "allow",       // 只允许 read
    }),
    user,
  ),
}
```

则 `edit`、`write`、`task` 等工具会在传给 LLM 前被删除。

---

### 第二层：运行时权限检查

即使工具通过了第一层过滤，在执行前还会进行一次权限验证。

**代码位置**：`packages/opencode/src/tool/edit.ts:91-99`

```typescript
await ctx.ask({
  permission: "edit",
  patterns: [path.relative(Instance.worktree, filePath)],
  always: ["*"],
  metadata: {
    filepath: filePath,
    diff,
  },
})

await file.write(contentNew) // 权限通过后才执行
```

**代码位置**：`packages/opencode/src/permission/next.ts:116-146`

```typescript
export const ask = fn(
  Request.partial({ id: true }).extend({
    ruleset: Ruleset,
  }),
  async (input) => {
    const s = await state()
    const { ruleset, ...request } = input
    for (const pattern of request.patterns ?? []) {
      const rule = evaluate(request.permission, pattern, ruleset, s.approved)
      log.info("evaluated", { permission: request.permission, pattern, action: rule })
      if (rule.action === "deny")
        throw new DeniedError(ruleset.filter((r) => Wildcard.match(request.permission, r.permission)))
      if (rule.action === "ask") {
        // 等待用户确认
        return new Promise<void>((resolve, reject) => {
          // ...
        })
      }
      if (rule.action === "allow") continue
    }
  },
)
```

**关键点**：

- 每个工具在执行关键操作前都会调用 `ctx.ask()`
- `ask()` 会评估权限规则
- `deny`：抛出 `DeniedError`，工具调用失败
- `ask`：暂停执行，等待用户确认
- `allow`：继续执行

---

### 第三层：系统提示词约束

只读 Agent 的提示词中明确告知不能进行编辑操作，从"软约束"层面进一步降低越权概率。

**代码位置**：`packages/opencode/src/session/prompt/plan.txt:25`

```markdown
The user indicated that they do not want you to execute yet -- you MUST NOT make any edits, run any non-readonly tools (including changing configs or making commits), or otherwise make any changes to system. This supersedes any other instructions you have received.
```

**作用**：

- 虽然不是强制约束，但会引导 LLM 的行为
- 配合前两层硬约束，形成完整防护

---

## 权限规则评估

权限规则的评估基于模式匹配，支持通配符。

**代码位置**：`packages/opencode/src/permission/next.ts:220-227`

```typescript
export function evaluate(permission: string, pattern: string, ...rulesets: Ruleset[]): Rule {
  const merged = merge(...rulesets)
  log.info("evaluate", { permission, pattern, ruleset: merged })
  const match = merged.findLast(
    (rule) => Wildcard.match(permission, rule.permission) && Wildcard.match(pattern, rule.pattern),
  )
  return match ?? { action: "ask", permission, pattern: "*" }
}
```

**规则优先级**：

- 后定义的规则优先级更高（`findLast`）
- 可以按路径、工具名称等模式匹配
- 未匹配到规则时默认为 `ask`

**示例规则**：

```typescript
;[
  { permission: "edit", pattern: "*", action: "deny" }, // 默认拒绝所有编辑
  { permission: "edit", pattern: ".opencode/plan/*", action: "allow" }, // 但允许编辑特定目录
]
```

---

## 完整流程示例

以 `plan` Agent 尝试编辑文件为例：

1. **工具过滤阶段**（`LLM.stream()` 调用前）
   - `resolveTools()` 检查 `edit` 工具权限
   - 规则为 `edit: { "*": "deny" }`
   - `edit` 工具从工具列表中删除
   - LLM 看不到 `edit` 工具

2. **如果 LLM 依然尝试调用 edit**
   - 不可能发生，因为工具不在列表中
   - LLM 只能调用系统提供的工具

3. **假设某个工具通过过滤**
   - 例如 `read` 工具权限为 `allow`
   - 工具执行时调用 `ctx.ask({ permission: "read", ... })`
   - `PermissionNext.ask()` 评估权限
   - 返回 `allow`，允许执行

---

## 为什么 LLM 无法越权

### 1. 信息隐藏

被禁用的工具不会出现在工具描述中，LLM 根本不知道它们的存在。

**代码证据**：`packages/opencode/src/session/llm.ts:158-159`

```typescript
tools,  // 传递给 streamText 的工具
activeTools: Object.keys(tools).filter((x) => x !== "invalid"),
```

`streamText()` 是 AI SDK 的函数，它将工具列表传给底层模型 API。被删除的工具不会出现在调用中。

### 2. API 层面约束

LLM 不是通过"理解"来遵守权限，而是被 API 限制了选择空间。

- LLM 只能返回它知道的工具调用
- 如果工具不在列表中，LLM 无法生成该工具的调用
- 即使 LLM"想"调用，也会被 API 拒绝

### 3. 双重检查

即使有漏洞（理论上不可能），工具内部还有权限检查：

```typescript
await ctx.ask({ permission: "edit", ... })  // 再次检查
await file.write(contentNew)                 // 检查通过才执行
```

### 4. 用户干预

`ask` 模式下，所有敏感操作都需要用户确认：

```typescript
if (rule.action === "ask") {
  return new Promise<void>((resolve, reject) => {
    // 暂停，等待用户通过 UI 确认
  })
}
```

---

## 安全边界

### 绝对安全的部分

- **工具过滤**：LLM 无法调用被删除的工具
- **权限拒绝**：`deny` 规则无法绕过，会直接抛出异常
- **权限询问**：`ask` 规则需要用户确认

### 依赖 LLM 配合的部分

- **系统提示词**：LLM 可能忽略，但前两层已足够
- **工具描述**：LLM 需要理解工具用途来正确调用
- **参数验证**：工具内部会验证参数（Zod schema）

---

## Agent 配置示例

### plan Agent（只读）

```typescript
plan: {
  name: "plan",
  permission: PermissionNext.merge(
    defaults,
    PermissionNext.fromConfig({
      edit: {
        "*": "deny",
        ".opencode/plan/*.md": "allow",  // 只能编辑特定目录
      },
    }),
    user,
  ),
  mode: "primary",
}
```

- 默认拒绝所有编辑操作
- 只能编辑 `.opencode/plan/*.md` 文件
- 其他编辑操作会被第一层和第二层防护拦截

### explore Agent（只读）

```typescript
explore: {
  permission: PermissionNext.merge(
    defaults,
    PermissionNext.fromConfig({
      "*": "deny",        // 默认拒绝所有
      grep: "allow",       // 允许 grep 搜索
      glob: "allow",       // 允许文件查找
      list: "allow",       // 允许列出文件
      bash: "allow",       // 允许执行 bash 命令
      webfetch: "allow",   // 允许获取网页内容
      websearch: "allow",  // 允许网络搜索
      codesearch: "allow", // 允许代码搜索
      read: "allow",       // 允许读取文件
      // edit, write 等工具被拒绝
    }),
    user,
  ),
}
```

- 严格限制为只读工具
- 无法进行任何修改操作
- 允许进行代码探索、搜索、网络查询等只读操作

### build Agent（完整权限）

```typescript
build: {
  name: "build",
  permission: PermissionNext.merge(defaults, user),
  mode: "primary",
}
```

- 继承默认权限配置
- 可以执行所有操作

---

## 总结

权限生效的保证机制：

1. **第一层**：工具列表过滤，LLM 根本看不到被禁用的工具
2. **第二层**：运行时权限检查，即使工具被调用也会被拦截
3. **第三层**：系统提示词约束，从软约束层面降低越权概率

**核心原理**：

- 权限控制不依赖 LLM 的"自律"
- 通过强制性的系统级约束实现
- LLM 只能在系统允许的范围内行动
- 被禁用的工具对 LLM 来说"不存在"

这种设计确保了即使 LLM 是"活的"，也无法越过权限限制。
