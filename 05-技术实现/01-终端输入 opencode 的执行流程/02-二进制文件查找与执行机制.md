# 二进制文件查找与执行机制

## 目录
- [1. 概述](#1-概述)
- [2. 为什么需要二进制分发](#2-为什么需要二进制分发)
- [3. 发布机制](#3-发布机制)
- [4. 实现原理](#4-实现原理)
- [5. 源码分析](#5-源码分析)
- [6. 平台支持矩阵](#6-平台支持矩阵)
- [7. 开发模式配置](#7-开发模式配置)
- [8. 常见问题](#8-常见问题)
- [9. 总结](#9-总结)

---

## 1. 概述

OpenCode CLI 采用 **多平台二进制分发机制**。用户全局安装 `opencode-ai` 包后，Shell Wrapper 层会自动根据操作系统和 CPU 架构，找到并执行对应的预编译二进制文件。

### 完整执行流程

```
用户输入: opencode
       │
       ▼
┌─────────────────────────────────────┐
│  bin/opencode (Shell Wrapper)      │
│  - 检查 OPENCODE_BIN_PATH 环境变量  │
│  - 检测 os.platform() 和 os.arch()  │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  构建包名前缀                        │
│  opencode-${platform}-${arch}       │
│  例如: opencode-darwin-arm64        │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  查找二进制文件                      │
│  - 从脚本目录向上遍历 node_modules   │
│  - 模糊匹配包名 (startsWith)        │
│  - 支持 baseline/musl 等变体         │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  执行二进制                          │
│  spawnSync(path, {stdio: inherit})  │
│  - 传递命令行参数                    │
│  - 继承 stdin/stdout/stderr          │
│  - 传递退出码                        │
└─────────────────────────────────────┘
```

---

## 2. 为什么需要二进制分发

### 2.1 性能优势

| 方案 | 启动时间 | 内存占用 | 说明 |
|------|---------|---------|------|
| **Node.js 脚本** | 较慢 (~500ms) | 高 | 需要 V8 编译、加载依赖 |
| **预编译二进制** | 快速 (~50ms) | 低 | 直接执行，无编译开销 |

### 2.2 跨平台分发挑战

不同操作系统和架构之间的二进制不兼容：

- **macOS Intel**: `darwin-x64`
- **macOS Apple Silicon**: `darwin-arm64` (M1/M2/M3)
- **Linux Intel**: `linux-x64`
- **Linux ARM**: `linux-arm64` (树莓派等)
- **Windows Intel**: `win32-x64`

**解决方案**: 使用 `optionalDependencies` 为每个平台发布独立的包，npm 会自动安装当前平台对应的包。

### 2.3 类似案例

Node.js 生态中广泛使用的方案：

- `node-pre-gyp`: Node.js 原生模块分发
- `prebuild-install`: 更快的原生模块安装
- `pkg`: 将 Node.js 打包成独立可执行文件

---

## 3. 发布机制

### 3.1 包结构

OpenCode 使用两级包结构：

**主包**: `opencode-ai`
- 包含 Shell Wrapper (`bin/opencode`)
- 包含 postinstall 脚本
- 通过 `optionalDependencies` 引用所有平台包

**平台包**: `opencode-${platform}-${arch}`
- 包含预编译的二进制文件
- 按平台和架构分类
- 支持变体（baseline、musl）

### 3.2 发布流程

```
1. 编译所有平台的二进制
   ↓
2. 为每个平台创建独立包
   - opencode-darwin-arm64
   - opencode-darwin-x64
   - opencode-linux-x64
   - opencode-darwin-x64-baseline (无 AVX2)
   - opencode-linux-x64-musl (Alpine)
   - ...等 11 个变体
   ↓
3. 创建主包 opencode-ai
   - 包含 Shell Wrapper
   - optionalDependencies 引用所有平台包
   - 配置 postinstall 脚本
   ↓
4. 发布到 npm
   - 每个平台包独立发布
   - 主包最后发布
```

### 3.3 package.json 配置

**主包** (`opencode-ai`):

```json
{
  "name": "opencode-ai",
  "version": "1.0.207",
  "bin": {
    "opencode": "./bin/opencode"
  },
  "scripts": {
    "postinstall": "bun ./postinstall.mjs || node ./postinstall.mjs"
  },
  "optionalDependencies": {
    "opencode-darwin-arm64": "1.0.207",
    "opencode-darwin-x64": "1.0.207",
    "opencode-darwin-x64-baseline": "1.0.207",
    "opencode-linux-arm64": "1.0.207",
    "opencode-linux-arm64-musl": "1.0.207",
    "opencode-linux-x64": "1.0.207",
    "opencode-linux-x64-baseline": "1.0.207",
    "opencode-linux-x64-musl": "1.0.207",
    "opencode-linux-x64-musl-baseline": "1.0.207",
    "opencode-windows-x64": "1.0.207",
    "opencode-windows-x64-baseline": "1.0.207"
  }
}
```

**平台包** (例如 `opencode-darwin-arm64`):

```json
{
  "name": "opencode-darwin-arm64",
  "version": "1.0.207",
  "os": ["darwin"],
  "cpu": ["arm64"]
}
```

**`optionalDependencies` 的作用**:
- npm 安装时自动选择当前平台的包
- 安装失败不会中断整体安装
- 允许在单个包中支持所有平台

### 3.4 postinstall 符号链接机制

**目的**: 在 Unix/macOS 系统上创建符号链接，简化 Shell Wrapper 的查找逻辑。

**工作流程**:

```
用户运行: npm install -g opencode-ai
         ↓
npm 下载并安装主包和平台包
         ↓
npm 运行 postinstall 脚本
         ↓
postinstall 检测当前平台 (如 darwin-arm64)
         ↓
查找对应的平台包 (opencode-darwin-arm64)
         ↓
创建符号链接:
  node_modules/opencode-ai/bin/opencode
  → node_modules/opencode-darwin-arm64/bin/opencode
         ↓
Shell Wrapper 可以使用相对路径快速查找
```

**Unix/macOS 实现** (`postinstall.mjs`):

```javascript
import fs from "fs"
import path from "path"
import os from "os"
import { createRequire } from "module"

const require = createRequire(import.meta.url)

function detectPlatformAndArch() {
  let platform
  switch (os.platform()) {
    case "darwin": platform = "darwin"; break
    case "linux": platform = "linux"; break
    case "win32": platform = "windows"; break
    default: platform = os.platform()
  }

  let arch
  switch (os.arch()) {
    case "x64": arch = "x64"; break
    case "arm64": arch = "arm64"; break
    case "arm": arch = "arm"; break
    default: arch = os.arch()
  }

  return { platform, arch }
}

function findBinary() {
  const { platform, arch } = detectPlatformAndArch()
  const packageName = `opencode-${platform}-${arch}`
  const binaryName = platform === "windows" ? "opencode.exe" : "opencode"

  // 使用 require.resolve 查找包
  const packageJsonPath = require.resolve(`${packageName}/package.json`)
  const packageDir = path.dirname(packageJsonPath)
  const binaryPath = path.join(packageDir, "bin", binaryName)

  if (!fs.existsSync(binaryPath)) {
    throw new Error(`Binary not found at ${binaryPath}`)
  }

  return { binaryPath, binaryName }
}

function symlinkBinary(sourcePath, binaryName) {
  const binDir = path.join(__dirname, "bin")
  const targetPath = path.join(binDir, binaryName)

  if (!fs.existsSync(binDir)) {
    fs.mkdirSync(binDir, { recursive: true })
  }

  if (fs.existsSync(targetPath)) {
    fs.unlinkSync(targetPath)
  }

  fs.symlinkSync(sourcePath, targetPath)
  console.log(`opencode binary symlinked: ${targetPath} -> ${sourcePath}`)
}

async function main() {
  // Windows 不需要符号链接
  if (os.platform() === "win32") {
    console.log("Windows detected: binary setup not needed (using packaged .exe)")
    return
  }

  const { binaryPath, binaryName } = findBinary()
  symlinkBinary(binaryPath, binaryName)
}

main()
```

**Windows 特殊处理**:
- 不需要符号链接
- `package.json` 的 `bin` 字段直接指向 `.exe` 文件
- postinstall 脚本检测到 Windows 后直接返回

---

## 4. 实现原理

### 4.1 平台检测映射

```javascript
// 操作系统映射
const platformMap = {
  darwin: "darwin",   // macOS
  linux: "linux",     // Linux
  win32: "windows",   // Windows
}

// CPU 架构映射
const archMap = {
  x64: "x64",         // Intel/AMD 64位
  arm64: "arm64",     // ARM 64位 (Apple Silicon)
  arm: "arm",         // ARM 32位
}
```

**平台回退机制**:

如果平台或架构不在映射表中，直接使用原始值：

```javascript
let platform = platformMap[os.platform()]
if (!platform) {
  platform = os.platform()  // 回退到原始平台名
}
let arch = archMap[os.arch()]
if (!arch) {
  arch = os.arch()  // 回退到原始架构名
}
```

这允许支持未预定义的平台（如 `freebsd`、`riscv64`）。

### 4.2 二进制命名规则

```
格式: opencode-${platform}-${arch}[-variant][-variant]

标准包名:
- opencode-darwin-x64      (macOS Intel)
- opencode-darwin-arm64    (macOS Apple Silicon)
- opencode-linux-x64       (Linux Intel)
- opencode-linux-arm64     (Linux ARM)
- opencode-windows-x64     (Windows Intel)

变体包名:
- opencode-darwin-x64-baseline        (macOS Intel, 无 AVX2)
- opencode-linux-x64-musl             (Linux, Alpine)
- opencode-linux-x64-musl-baseline    (Linux, Alpine, 无 AVX2)
```

**变体说明**:
- **baseline**: 不使用 AVX2 指令集，兼容旧 CPU
- **musl**: 使用 musl libc，兼容 Alpine Linux

### 4.3 查找算法

**关键特性**: 使用模糊匹配 (`startsWith`) 支持包名变体。

**向上遍历 node_modules 树**:

```
脚本目录 (packages/opencode/bin/)
       ↓
上一级目录 (packages/opencode/)
       ↓
根目录 (packages/)
       ↓
根 node_modules/
       ↓
找到平台包
```

**查找逻辑** (`bin/opencode:50-72`):

```javascript
function findBinary(startDir) {
  let current = startDir
  const base = `opencode-${platform}-${arch}`  // 例如: opencode-darwin-arm64

  for (;;) {
    const modules = path.join(current, "node_modules")

    // 检查 node_modules 是否存在
    if (fs.existsSync(modules)) {
      const entries = fs.readdirSync(modules)

      // 遍历所有包，查找匹配前缀的包
      for (const entry of entries) {
        if (!entry.startsWith(base)) {
          continue  // 跳过不匹配的包
        }

        // 构造二进制路径
        const candidate = path.join(modules, entry, "bin", binary)

        if (fs.existsSync(candidate)) {
          return candidate  // 找到！
        }
      }
    }

    // 向上遍历到父目录
    const parent = path.dirname(current)
    if (parent === current) {
      return undefined  // 到达根目录，未找到
    }
    current = parent
  }
}
```

**为什么使用 `startsWith`**?

假设当前平台是 `linux-x64`，以下包名都会被匹配：
- ✅ `opencode-linux-x64` (标准)
- ✅ `opencode-linux-x64-baseline` (无 AVX2)
- ✅ `opencode-linux-x64-musl` (Alpine)

npm 会根据系统特性安装最合适的包，查找时匹配前缀即可。

### 4.4 执行机制

使用 `child_process.spawnSync` 执行：

```javascript
const childProcess = require("child_process")

function run(binaryPath) {
  const result = childProcess.spawnSync(binaryPath, process.argv.slice(2), {
    stdio: "inherit",  // 继承 stdin/stdout/stderr
  })

  // 检查执行错误
  if (result.error) {
    console.error(result.error.message)
    process.exit(1)
  }

  // 传递退出码
  const code = typeof result.status === "number" ? result.status : 0
  process.exit(code)
}
```

**`stdio: "inherit"` 的作用**:

- 让子进程直接使用父进程的标准输入、输出、错误流
- 用户在终端输入的命令直接传递给二进制
- 二进制的输出直接显示在终端
- 实现透明代理，用户感觉不到中间层存在

**错误处理**:

- `result.error`: 二进制文件不存在、无执行权限等
- `result.status`: 二进制的退出码
- 使用 `typeof` 检查确保 `status` 是有效数字

---

## 5. 源码分析

### 5.1 Shell Wrapper 完整实现

**文件**: `packages/opencode/bin/opencode`

```javascript
#!/usr/bin/env node

const childProcess = require("child_process")
const fs = require("fs")
const path = require("path")
const os = require("os")

function run(target) {
  const result = childProcess.spawnSync(target, process.argv.slice(2), {
    stdio: "inherit",
  })

  if (result.error) {
    console.error(result.error.message)
    process.exit(1)
  }

  const code = typeof result.status === "number" ? result.status : 0
  process.exit(code)
}

// 1. 检查环境变量（开发模式）
const envPath = process.env.OPENCODE_BIN_PATH
if (envPath) {
  run(envPath)  // 注意：这里会直接退出，不会继续执行后续代码
}

// 2. 获取脚本所在目录（而非当前工作目录）
const scriptPath = fs.realpathSync(__filename)
const scriptDir = path.dirname(scriptPath)

// 3. 检测平台和架构
const platformMap = {
  darwin: "darwin",
  linux: "linux",
  win32: "windows",
}

const archMap = {
  x64: "x64",
  arm64: "arm64",
  arm: "arm",
}

let platform = platformMap[os.platform()]
if (!platform) {
  platform = os.platform()  // 回退到原始值
}

let arch = archMap[os.arch()]
if (!arch) {
  arch = os.arch()  // 回退到原始值
}

// 4. 构建包名前缀和二进制文件名
const base = "opencode-" + platform + "-" + arch
const binary = platform === "windows" ? "opencode.exe" : "opencode"

// 5. 查找二进制
function findBinary(startDir) {
  let current = startDir

  for (;;) {
    const modules = path.join(current, "node_modules")

    if (fs.existsSync(modules)) {
      const entries = fs.readdirSync(modules)

      for (const entry of entries) {
        if (!entry.startsWith(base)) {
          continue
        }

        const candidate = path.join(modules, entry, "bin", binary)

        if (fs.existsSync(candidate)) {
          return candidate
        }
      }
    }

    const parent = path.dirname(current)
    if (parent === current) {
      return  // 到达根目录，返回 undefined
    }
    current = parent
  }
}

// 6. 执行查找并处理结果
const resolved = findBinary(scriptDir)

if (!resolved) {
  console.error(
    'It seems that your package manager failed to install the right version ' +
    'of the opencode CLI for your platform. You can try manually installing the "' +
      base +
      '" package'
  )
  process.exit(1)
}

// 7. 执行二进制
run(resolved)
```

### 5.2 关键设计点

#### 设计点 1: 环境变量优先

```javascript
const envPath = process.env.OPENCODE_BIN_PATH
if (envPath) {
  run(envPath)  // 直接执行并退出
}
```

**用途**:
- **开发模式**: 开发者可以指定自定义编译的二进制
- **调试**: 绕过自动检测，直接执行特定版本
- **测试**: 测试不同平台的二进制

**重要**: 设置 `OPENCODE_BIN_PATH` 会**完全绕过**平台检测和查找逻辑。

**示例**:
```bash
# 开发时使用本地编译的二进制
export OPENCODE_BIN_PATH=./dist/opencode-darwin-arm64/bin/opencode
opencode
```

#### 设计点 2: 从脚本目录开始查找

```javascript
const scriptPath = fs.realpathSync(__filename)
const scriptDir = path.dirname(scriptPath)
const resolved = findBinary(scriptDir)
```

**为什么不是 `process.cwd()`**:
- `process.cwd()` 是用户执行命令的目录
- `scriptDir` 是 Shell Wrapper 脚本所在的目录
- 从 `scriptDir` 开始查找可以更快找到平台包

**示例**:
```
用户在 /home/user/project 执行 opencode
process.cwd() = /home/user/project
scriptDir = /usr/local/lib/node_modules/opencode-ai/bin
```

#### 设计点 3: 模糊匹配支持变体

```javascript
if (!entry.startsWith(base)) {
  continue
}
```

**匹配示例**:
- `base = "opencode-linux-x64"`
- 匹配: `opencode-linux-x64`, `opencode-linux-x64-baseline`, `opencode-linux-x64-musl`
- 不匹配: `opencode-darwin-arm64`, `other-package`

#### 设计点 4: Windows 处理

```javascript
const binary = platform === "windows" ? "opencode.exe" : "opencode"
```

**差异**:
- **Windows**: 二进制文件名是 `opencode.exe`
- **Unix/macOS**: 二进制文件名是 `opencode` (无扩展名)

**postinstall 中的 Windows 处理**:

```javascript
if (os.platform() === "win32") {
  // Windows 不需要符号链接
  console.log("Windows detected: binary setup not needed (using packaged .exe)")
  return
}
```

#### 设计点 5: 友好的错误消息

```javascript
if (!resolved) {
  console.error(
    'It seems that your package manager failed to install the right version ' +
    'of the opencode CLI for your platform. You can try manually installing the "' +
      base +
      '" package'
  )
  process.exit(1)
}
```

**作用**:
- 告诉用户具体缺失的包名
- 建议手动安装方案
- 包含诊断信息

#### 设计点 6: 退出码传递

```javascript
const code = typeof result.status === "number" ? result.status : 0
process.exit(code)
```

**作用**:
- 将二进制的退出码传递给父进程
- 使用 `typeof` 检查确保 `status` 是有效数字
- 保证 Shell 脚本可以正确检测执行结果

```bash
# Shell 可以检测执行是否成功
opencode
if [ $? -eq 0 ]; then
  echo "Success"
fi
```

---

## 6. 平台支持矩阵

### 6.1 支持的平台和变体

| 操作系统 | 架构 | 变体 | 包名 | 二进制文件 |
|---------|------|------|------|-----------|
| **macOS** | x64 (Intel) | 标准 | `opencode-darwin-x64` | `bin/opencode` |
| **macOS** | x64 (Intel) | baseline | `opencode-darwin-x64-baseline` | `bin/opencode` |
| **macOS** | arm64 (M1/M2/M3) | 标准 | `opencode-darwin-arm64` | `bin/opencode` |
| **Linux** | x64 | 标准 | `opencode-linux-x64` | `bin/opencode` |
| **Linux** | x64 | baseline | `opencode-linux-x64-baseline` | `bin/opencode` |
| **Linux** | x64 | musl | `opencode-linux-x64-musl` | `bin/opencode` |
| **Linux** | x64 | musl + baseline | `opencode-linux-x64-musl-baseline` | `bin/opencode` |
| **Linux** | arm64 | 标准 | `opencode-linux-arm64` | `bin/opencode` |
| **Linux** | arm64 | musl | `opencode-linux-arm64-musl` | `bin/opencode` |
| **Windows** | x64 | 标准 | `opencode-windows-x64` | `bin/opencode.exe` |
| **Windows** | x64 | baseline | `opencode-windows-x64-baseline` | `bin/opencode.exe` |

**变体说明**:
- **标准**: 使用 AVX2 指令集（如果可用），使用 glibc（Linux）
- **baseline**: 不使用 AVX2 指令集，兼容旧 CPU
- **musl**: 使用 musl libc，兼容 Alpine Linux

### 6.2 检测命令

查看你的平台和架构：

```bash
# Node.js 方式
node -e "console.log(process.platform, process.arch)"

# 输出示例:
# darwin arm64   (Mac M1/M2/M3)
# darwin x64     (Mac Intel)
# linux x64      (Linux Intel)
# linux arm64    (Linux ARM)
# win32 x64      (Windows 64位)
```

### 6.3 操作系统版本要求

| 操作系统 | 最低版本 | 说明 |
|---------|---------|------|
| **macOS** | 10.15+ (Catalina) | Intel 和 Apple Silicon 均支持 |
| **Linux** | 内核 3.10+ | glibc 2.17+ (标准版) |
| **Alpine Linux** | 3.12+ | 需要 musl 版本 |
| **Windows** | Windows 10+ | 64位系统 |

### 6.4 CPU 特性要求

**标准版**:
- x64: 支持 AVX2 指令集（2014年后的 Intel/AMD CPU）
- arm64: ARMv8-A (2014年后)

**baseline 版本**:
- x64: 不需要 AVX2，支持更老的 CPU
- arm64: 同标准版

**如何判断是否需要 baseline 版本**:

```bash
# Linux 查看 CPU 特性
grep avx2 /proc/cpuinfo

# 有输出 → 使用标准版
# 无输出 → 考虑使用 baseline 版本
```

### 6.5 实际安装示例

```bash
# 全局安装
npm install -g opencode-ai

# 安装的包结构（Unix/macOS）:
# ~/.nvm/versions/node/v20.x/lib/node_modules/opencode-ai/
# ├── bin/
# │   └── opencode          (Shell Wrapper)
# ├── postinstall.mjs       (安装脚本)
# ├── package.json
# └── node_modules/
#     ├── opencode-darwin-arm64/  ← 当前平台包
#     │   └── bin/
#     │       └── opencode  (实际二进制)
#     ├── opencode-darwin-x64/
#     ├── opencode-linux-x64/
#     └── ... (其他平台包不会被安装)

# 符号链接（Unix/macOS）:
# ~/.nvm/versions/node/v20.x/lib/node_modules/opencode-ai/bin/opencode
# → ../node_modules/opencode-darwin-arm64/bin/opencode
```

---

## 7. 开发模式配置

### 7.1 使用 OPENCODE_BIN_PATH

**场景**: 本地开发时使用未发布的二进制

```bash
# 方法 1: 临时设置（单次执行）
OPENCODE_BIN_PATH=./dist/opencode-darwin-arm64/bin/opencode opencode

# 方法 2: 设置环境变量（当前会话）
export OPENCODE_BIN_PATH=./dist/opencode-darwin-arm64/bin/opencode
opencode

# 方法 3: .envrc (direnv)
echo 'export OPENCODE_BIN_PATH=./dist/opencode-darwin-arm64/bin/opencode' > .envrc
direnv allow
```

### 7.2 本地编译和测试

**OpenCode 使用 Bun 编译**:

```bash
# 进入包目录
cd packages/opencode

# 安装依赖
bun install

# 编译当前平台（调试版本）
bun run build --single

# 编译当前平台（发布版本）
bun run build --single

# 编译所有平台
bun run build

# 输出位置:
# dist/opencode-${platform}-${arch}/bin/opencode
```

**使用编译的二进制**:

```bash
# 方法 1: 直接执行
./dist/opencode-darwin-arm64/bin/opencode --version

# 方法 2: 通过环境变量
export OPENCODE_BIN_PATH=./dist/opencode-darwin-arm64/bin/opencode
opencode --version

# 方法 3: 运行完整测试
bun run test
```

### 7.3 跨平台编译

**Bun 支持交叉编译**:

```bash
# 编译特定平台
bun install --os="darwin" --arch="x64"
bun run build --single

# 编译所有平台
bun run build
```

**输出示例**:

```bash
dist/
├── opencode-darwin-arm64/
│   └── bin/
│       └── opencode
├── opencode-darwin-x64/
│   └── bin/
│       └── opencode
├── opencode-linux-x64/
│   └── bin/
│       └── opencode
├── opencode-linux-x64-baseline/
│   └── bin/
│       └── opencode
└── ...
```

### 7.4 发布流程

```bash
# 1. 编译所有平台
bun run build

# 2. 运行测试（当前平台）
bun run test

# 3. 发布所有包
bun run publish

# 这会执行:
# - 编译所有平台二进制
# - 为每个平台创建 npm 包
# - 运行 smoke test
# - 打包并发布到 npm
```

---

## 8. 常见问题

### Q1: 为什么不能直接用 Node.js 脚本？

**A**: 预编译二进制的优势：

1. **启动速度**: 二进制 (~50ms) vs Node.js (~500ms)
2. **内存占用**: 二进制 < Node.js 运行时
3. **分发便利**: 单文件，无需依赖 Node.js 环境（可选）
4. **性能**: 编译型语言的运行时性能更高

**代价**:
- 需要为每个平台单独编译
- 增加包体积（npm 包包含所有平台包，但安装时只下载当前平台）

### Q2: 如何查看当前使用的二进制路径？

**A**: 添加调试输出：

```javascript
// 在 bin/opencode 的 run 函数前添加
console.log(`Using binary: ${binaryPath}`)
run(resolved)
```

或检查安装：

```bash
# 查看 opencode-ai 安装位置
npm list -g opencode-ai

# 查看平台包
npm list -g opencode-darwin-arm64  # 替换为你的平台

# 查看符号链接（Unix/macOS）
ls -l $(npm root -g)/opencode-ai/bin/opencode
```

### Q3: 支持哪些平台？

**A**: 当前支持：

**✅ 完全支持**:
- macOS 10.15+ (Intel & Apple Silicon)
- Ubuntu 18.04+ / Debian 10+ (x64 & arm64)
- Alpine Linux 3.12+ (x64 & arm64)
- Windows 10+ (x64)

**⚠️ 实验性支持** (通过平台回退机制):
- FreeBSD (x64)
- OpenBSD (x64)
- 其他支持 Node.js 的 Unix 系统

**❌ 不支持**:
- 32位系统 (x86, arm32)
- Windows on ARM (WOA)
- Linux 发行版使用过旧的 glibc (< 2.17)

### Q4: 安装后提示找不到二进制怎么办？

**A**: 诊断步骤：

```bash
# 1. 检查平台
node -e "console.log(process.platform, process.arch)"

# 2. 检查主包安装
npm list -g opencode-ai

# 3. 检查平台包安装
npm list -g opencode-$(node -e "console.log(process.platform)")-$(node -e "console.log(process.arch)")

# 4. 查找二进制包
find $(npm root -g) -name "opencode-*" -type d -maxdepth 1

# 5. 手动安装平台包
npm install -g opencode-darwin-arm64  # 替换为你的平台

# 6. 重新安装
npm uninstall -g opencode-ai
npm install -g opencode-ai
```

### Q5: 什么是 baseline 版本？我需要吗？

**A**: baseline 版本不使用 AVX2 指令集。

**谁需要 baseline**:
- 2014年前后的 Intel/AMD CPU
- 虚拟机环境（某些云虚拟机不支持 AVX2）
- 容器环境（某些容器未正确传递 CPU 特性）

**谁不需要 baseline**:
- 近年的物理机（2015年后）
- 现代云服务器（AWS, GCP, Azure 的现代实例）

**检查是否支持 AVX2**:

```bash
# Linux
grep avx2 /proc/cpuinfo

# macOS
sysctl -a | grep avx2

# 有输出 → 使用标准版
# 无输出 → 使用 baseline 版本
```

### Q6: 什么是 musl 版本？我需要吗？

**A**: musl 版本使用 musl libc 而非 glibc。

**谁需要 musl**:
- Alpine Linux 用户
- Docker 镜像基于 Alpine
- 需要 静态链接的部署环境

**谁不需要 musl**:
- Ubuntu, Debian, Fedora, CentOS 用户
- Docker 镜像基于 Debian/Ubuntu

**检查 libc 类型**:

```bash
# 检查当前使用的 libc
ldd --version

# 输出包含 "musl" → 需要 musl 版本
# 输出包含 "glibc" 或 "GNU" → 使用标准版本
```

### Q7: 如何添加新平台支持？

**A**: 步骤：

1. **更新编译脚本** (`packages/opencode/script/build.ts`):

   ```javascript
   const allTargets = [
     // 现有平台...
     {
       os: "freebsd",  // 新增
       arch: "x64",
     },
   ]
   ```

2. **编译新平台二进制**:

   ```bash
   bun install --os="freebsd" --arch="x64"
   bun run build --single
   ```

3. **创建并发布平台包**:

   ```bash
   cd dist/opencode-freebsd-x64
   npm publish
   ```

4. **更新主包 optionalDependencies**:

   ```json
   {
     "optionalDependencies": {
       "opencode-freebsd-x64": "1.0.207"
     }
   }
   ```

### Q8: Windows 上的 `opencode.exe` 是如何生成的？

**A**: Bun 编译时自动添加 `.exe` 扩展名。

**编译配置** (`build.ts:137`):

```javascript
await Bun.build({
  compile: {
    target: name.replace(pkg.name, "bun") as any,
    outfile: `dist/${name}/bin/opencode`,  // 不带扩展名
    windows: {},  // Windows 平台会自动添加 .exe
  },
})
```

**输出**:
- Windows: `dist/opencode-windows-x64/bin/opencode.exe`
- Unix/macOS: `dist/opencode-darwin-arm64/bin/opencode`

### Q9: 为什么使用 `spawnSync` 而不是 `spawn`？

**A**: 原因：

1. **同步等待**: Shell Wrapper 需要等待二进制执行完毕
2. **退出码传递**: 需要获取二进制的退出状态
3. **简洁性**: 不需要处理异步事件循环

```javascript
// spawnSync 示例（实际使用）
const result = spawnSync(binaryPath, args, {
  stdio: "inherit",
})
if (result.error) {
  console.error(result.error.message)
  process.exit(1)
}
process.exit(result.status ?? 0)

// 如果用 spawn，需要这样：
spawn(binaryPath, args, { stdio: "inherit" })
  .on("error", (err) => {
    console.error(err.message)
    process.exit(1)
  })
  .on("close", (code) => {
    process.exit(code ?? 0)
  })
```

### Q10: 为什么我的二进制是符号链接？

**A**: Unix/macOS 系统上，postinstall 脚本会创建符号链接。

**目的**: 简化 Shell Wrapper 的查找逻辑。

**验证**:

```bash
# 查看符号链接
ls -l $(which opencode)

# 输出示例:
# /usr/local/bin/opencode -> ../lib/node_modules/opencode-ai/bin/opencode
# ../lib/node_modules/opencode-ai/bin/opencode -> ../node_modules/opencode-darwin-arm64/bin/opencode
```

**Windows**: 不使用符号链接，直接指向 `.exe` 文件。

### Q11: 如何在不同平台上测试？

**A**: 使用 Docker 或虚拟机。

**Docker 示例**:

```bash
# Alpine Linux (musl)
docker run --rm -v $(pwd):/app -w /app alpine:latest sh -c "apk add nodejs npm && npm install -g opencode-ai && opencode --version"

# Ubuntu (glibc)
docker run --rm -v $(pwd):/app -w /app ubuntu:latest sh -c "apt update && apt install -y nodejs npm && npm install -g opencode-ai && opencode --version"
```

**虚拟机**:
- 使用 Vagrant 或 VirtualBox 测试不同操作系统
- 使用 CI/CD 服务（GitHub Actions）进行多平台测试

---

## 9. 总结

### 核心要点

1. **多平台支持**: 使用 `optionalDependencies` 自动选择当前平台包
2. **模糊匹配**: `startsWith` 支持包名变体（baseline、musl）
3. **符号链接**: Unix/macOS 使用 postinstall 创建符号链接简化查找
4. **开发友好**: `OPENCODE_BIN_PATH` 环境变量支持自定义二进制路径
5. **错误处理**: 友好的错误消息和退出码传递

### 架构优势

```
用户执行: opencode
    ↓
Shell Wrapper (bin/opencode)
    ↓ 环境变量检查 → 平台检测 → 模糊匹配查找
平台特定二进制 (opencode-darwin-arm64/bin/opencode)
    ↓ 执行
Bun 编译的 CLI (src/index.ts)
    ↓
Worker + RPC + TUI
```

**设计优势**:
- ✅ 用户安装体验一致（`npm install -g opencode-ai`）
- ✅ npm 自动处理平台选择
- ✅ 支持多种平台变体（baseline、musl）
- ✅ 开发者可以本地测试
- ✅ 易于添加新平台支持
- ✅ 友好的错误提示

### 技术亮点

1. **optionalDependencies 技巧**: npm 自动安装当前平台包
2. **模糊匹配算法**: 支持包名变体
3. **postinstall 符号链接**: 简化查找逻辑
4. **平台回退机制**: 支持未预定义的平台
5. **完整的错误处理**: 清晰的错误消息

---

## 参考资源

- [Node.js child_process 文档](https://nodejs.org/api/child_process.html)
- [npm optionalDependencies](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#optionaldependencies)
- [Bun 编译文档](https://bun.sh/docs/bundler)
- [Node.js ESM 模块](https://nodejs.org/api/esm.html)
- [pkg - Node.js 打包工具](https://github.com/vercel/pkg)
- [node-pre-gyp 原生模块分发](https://github.com/mapbox/node-pre-gyp)
