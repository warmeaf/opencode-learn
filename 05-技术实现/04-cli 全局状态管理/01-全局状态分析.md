# CLI 全局状态管理分析

## 概述

OpenCode CLI 的全局状态管理采用了多种机制组合的方式，包括：

- **AsyncLocalStorage** - 用于实例级别的上下文传递
- **全局 Map** - 用于缓存和状态管理
- **EventEmitter** - 用于事件驱动架构
- **文件系统** - 用于持久化存储
- **环境变量** - 用于配置标志

---

## 1. Global Path (全局路径)

**位置**: `src/global/index.ts`

**状态内容**:

```typescript
{
  home: string,        // 用户主目录
  data: string,        // 数据目录
  bin: string,         // 二进制目录
  log: string,         // 日志目录
  cache: string,       // 缓存目录
  config: string,      // 配置目录
  state: string        // 状态目录
}
```

**管理方式**:

- 使用 XDG Base Directory 规范
- 模块加载时自动创建目录
- 缓存版本控制（CACHE_VERSION = "14"）

**用途**:

- 提供全局文件路径常量
- 确保数据存储位置一致
- 支持缓存清理和版本管理

---

## 2. Context (异步上下文)

**位置**: `src/util/context.ts`

**状态内容**:

- 基于 Node.js `AsyncLocalStorage` 实现
- 每个类型独立的存储空间

**管理方式**:

```typescript
// 创建上下文存储
const context = Context.create<ContextType>("instance")

// 提供上下文
context.provide(contextData, () => { ... })

// 获取当前上下文
context.use()
```

**用途**:

- 用于 `Instance` 模块存储项目实例上下文
- 支持多实例隔离
- 确保异步操作中的上下文一致性

**使用示例** (src/project/instance.ts):

```typescript
interface Context {
  directory: string
  worktree: string
  project: Project.Info
}
const context = Context.create<Context>("instance")
```

---

## 3. Instance State (实例状态)

**位置**: `src/project/instance.ts`

**状态内容**:

- **目录信息**: 当前工作目录、git worktree
- **项目信息**: Project.Info（项目 ID、名称、VCS 类型等）
- **缓存机制**: Map<string, Promise<Context>> 缓存已创建的实例

**管理方式**:

### 3.1 实例缓存

```typescript
const cache = new Map<string, Promise<Context>>()

// Instance.provide() 方法
export const Instance = {
  async provide<R>(input: { directory: string; init?: () => Promise<any>; fn: () => R }): Promise<R> {
    let existing = cache.get(input.directory)
    if (!existing) {
      existing = iife(async () => {
        // 创建新实例
        const project = await Project.fromDirectory(input.directory)
        const ctx = { directory, worktree, project }
        await context.provide(ctx, async () => { ... })
        return ctx
      })
      cache.set(input.directory, existing)
    }
    // 复用已有实例
    const ctx = await existing
    return context.provide(ctx, async () => { input.fn() })
  }
}
```

### 3.2 状态创建

```typescript
Instance.state<S>(init: () => S, dispose?: (state: S) => Promise<void>): () => S
```

- 为每个实例创建独立状态
- 支持状态初始化和清理
- 基于 State.create() 实现

**用途**:

- 管理每个项目的独立状态
- 支持多项目同时操作
- 提供实例级别的资源隔离

---

## 4. State (通用状态管理)

**位置**: `src/project/state.ts`

**状态内容**:

```typescript
const recordsByKey = new Map<string, Map<any, Entry>>()

interface Entry {
  state: any
  dispose?: (state: any) => Promise<void>
}
```

**管理方式**:

- **双层 Map**: 外层按 key（通常是目录）分组，内层按 init 函数分组
- **延迟初始化**: 首次调用时创建状态，后续复用
- **自动清理**: dispose 时调用所有 dispose 函数

**使用示例**:

```typescript
// 在 Bus 模块中使用
const state = Instance.state(
  () => {
    const subscriptions = new Map<any, Subscription[]>()
    return { subscriptions }
  },
  async (entry) => {
    // 清理逻辑
  },
)
```

**用途**:

- 提供通用的状态管理基类
- 支持实例级别的状态隔离
- 自动管理生命周期

---

## 5. Bus (事件总线)

**位置**: `src/bus/index.ts`, `src/bus/global.ts`

**状态内容**:

### 5.1 实例级事件总线

```typescript
const state = Instance.state(() => {
  const subscriptions = new Map<any, Subscription[]>()
  return { subscriptions }
})
```

### 5.2 全局事件总线

```typescript
export const GlobalBus = new EventEmitter<{
  event: [{ directory?: string; payload: any }]
}>()
```

**管理方式**:

- **发布/订阅模式**: 支持事件发布和订阅
- **通配符支持**: "\*" 可订阅所有事件
- **实例隔离**: 每个实例有独立的订阅列表

**使用示例**:

```typescript
// 发布事件
await Bus.publish(EventDef, { properties })

// 订阅事件
const unsub = Bus.subscribe(EventDef, (event) => { ... })

// 一次性订阅
Bus.once(EventDef, (event) => { ... })
```

**用途**:

- 解耦模块间通信
- 支持跨实例的事件通知
- 实现响应式更新机制

---

## 6. Config (配置状态)

**位置**: `src/config/config.ts`

**状态内容**:

```typescript
const state = Instance.state(async () => {
  return {
    config: Info,           // 配置对象
    directories: string[]   // 配置文件目录列表
  }
})
```

**配置层级** (从低到高优先级):

1. 全局配置文件 (`config.json`, `opencode.json`, `opencode.jsonc`)
2. `OPENCODE_CONFIG` 环境变量
3. 项目配置文件 (向上查找 `opencode.jsonc`, `opencode.json`)
4. `OPENCODE_CONFIG_CONTENT` 环境变量
5. wellknown 认证配置
6. `.opencode` 目录配置
7. `OPENCODE_CONFIG_DIR` 目录
8. `OPENCODE_PERMISSION` 权限配置
9. `OPENCODE_DISABLE_AUTOCOMPACT` 标志
10. `OPENCODE_DISABLE_PRUNE` 标志

**管理方式**:

- **延迟加载**: 使用 `lazy` 实现按需加载
- **深度合并**: 使用 `mergeDeep` 合并多层级配置
- **插件合并**: plugin 数组特殊处理（拼接而非替换）

**用途**:

- 管理用户配置
- 支持多环境配置
- 实现配置热更新

---

## 7. Auth (认证状态)

**位置**: `src/auth/index.ts`

**状态内容**:

```typescript
// 持久化到文件
const filepath = path.join(Global.Path.data, "auth.json")

interface Info {
  type: "oauth" | "api" | "wellknown"
  // ... 其他字段
}
```

**管理方式**:

- **文件存储**: `auth.json` 文件持久化
- **权限控制**: 文件权限设置为 0o600
- **增删改查**: 提供完整的 CRUD 操作

**用途**:

- 管理认证令牌
- 支持多种认证方式
- 保证认证信息安全

---

## 8. Storage (存储状态)

**位置**: `src/storage/storage.ts`

**状态内容**:

```typescript
const state = lazy(async () => {
  const dir = path.join(Global.Path.data, "storage")
  // 运行数据迁移
  const migration = await Bun.file(path.join(dir, "migration")).json()
  // ...
  return { dir }
})
```

**管理方式**:

- **JSON 存储**: 所有数据以 JSON 格式存储
- **文件锁**: 使用 Lock 机制防止并发冲突
- **数据迁移**: 支持版本化的数据迁移
- **错误处理**: 统一的错误处理机制

**使用示例**:

```typescript
// 读取
await Storage.read<T>(["session", sessionID])

// 写入
await Storage.write<T>(["session", sessionID], data)

// 更新
await Storage.update<T>(["session", sessionID], (draft) => { ... })

// 删除
await Storage.remove(["session", sessionID])

// 列表
await Storage.list(["session", projectID])
```

**用途**:

- 统一的数据持久化接口
- 管理会话、消息等数据
- 提供原子性保证

---

## 9. Flag (环境变量标志)

**位置**: `src/flag/flag.ts`

**状态内容**:

```typescript
export const Flag = {
  OPENCODE_CONFIG: process.env["OPENCODE_CONFIG"],
  OPENCODE_CONFIG_DIR: process.env["OPENCODE_CONFIG_DIR"],
  OPENCODE_DISABLE_AUTOUPDATE: truthy("OPENCODE_DISABLE_AUTOUPDATE"),
  OPENCODE_EXPERIMENTAL: truthy("OPENCODE_EXPERIMENTAL"),
  // ... 更多标志
}
```

**管理方式**:

- **只读常量**: 模块加载时从环境变量读取
- **类型转换**: truthy() 和 number() 辅助函数
- **不可变性**: 运行时不修改

**用途**:

- 控制功能开关
- 覆盖默认配置
- 支持实验性功能

---

## 10. Log (日志状态)

**位置**: `src/util/log.ts`

**状态内容**:

```typescript
let level: Level = "INFO"
let logpath = ""
const loggers = new Map<string, Logger>()
let write: (msg: any) => number
```

**管理方式**:

- **日志级别**: 支持分级日志（DEBUG, INFO, WARN, ERROR）
- **文件轮转**: 当日志文件数 > 5 时自动清理，保留最后 10 个
- **Logger 缓存**: 按 service 名称缓存 logger 实例

**用途**:

- 统一日志接口
- 支持日志持久化
- 提供调试和诊断功能

---

## 11. Installation (安装状态)

**位置**: `src/installation/index.ts`

**状态内容**:

```typescript
export const VERSION = typeof OPENCODE_VERSION === "string" ? OPENCODE_VERSION : "local"
export const CHANNEL = typeof OPENCODE_CHANNEL === "string" ? OPENCODE_CHANNEL : "local"
export const USER_AGENT = `opencode/${CHANNEL}/${VERSION}/${Flag.OPENCODE_CLIENT}`
```

**管理方式**:

- **编译时常量**: 构建时注入版本和渠道
- **运行时检测**: 检测安装方式（npm, brew, curl 等）
- **版本检查**: 支持检查最新版本

**用途**:

- 管理版本信息
- 支持自动更新
- 提供用户代理信息

---

## 12. Project (项目状态)

**位置**: `src/project/project.ts`

**状态内容**:

```typescript
export const Info = z.object({
  id: string,
  worktree: string,
  vcs: "git" | undefined,
  name: string | undefined,
  icon: { url: string, color: string } | undefined,
  time: {
    created: number,
    updated: number,
    initialized: number | undefined,
  },
})
```

**管理方式**:

- **持久化**: 使用 Storage 接口存储
- **自动发现**: 检测 git 仓库和工作树
- **事件通知**: 更新时发送 GlobalBus 事件

**用途**:

- 管理项目元信息
- 支持 git 仓库检测
- 提供项目图标发现

---

## 13. Session (会话状态)

**位置**: `src/session/index.ts`

**状态内容**:

```typescript
export const Info = z.object({
  id: string,
  projectID: string,
  directory: string,
  parentID: string | undefined,
  summary: { additions: number, deletions: number, files: number, diffs?: FileDiff[] } | undefined,
  share: { url: string } | undefined,
  title: string,
  version: string,
  time: {
    created: number,
    updated: number,
    compacting: number | undefined,
    archived: number | undefined
  },
  revert: {
    messageID: string,
    partID: string | undefined,
    snapshot: string | undefined,
    diff: string | undefined
  } | undefined
})
```

**管理方式**:

- **存储**: 使用 Storage 接口持久化
- **事件驱动**: 创建、更新、删除时触发事件
- **层次结构**: 支持父子会话关系

**用途**:

- 管理对话会话
- 支持会话分支和合并
- 提供会话压缩和归档

---

## 状态管理架构总结

### 架构特点

1. **分层设计**
   - 全局层: Global, Log, Installation
   - 实例层: Instance, Config, Bus
   - 持久层: Storage, Auth, Project, Session

2. **生命周期管理**

   ```
   创建 → 缓存 → 使用 → 清理
   ```

3. **隔离机制**
   - 实例隔离: AsyncLocalStorage + Instance.state
   - 文件隔离: 项目级别的存储路径
   - 事件隔离: 实例级事件总线

4. **通信机制**
   - 同步: 直接调用 (如 Instance.directory)
   - 异步: 事件发布/订阅 (Bus.publish/subscribe)
   - 跨实例: GlobalBus

### 设计模式

1. **单例模式**: Log, Flag, Installation
2. **工厂模式**: Instance.provide, State.create
3. **发布/订阅**: Bus, GlobalBus
4. **仓储模式**: Storage
5. **上下文模式**: Context/AsyncLocalStorage

### 数据流

```
用户请求
  ↓
CLI 命令
  ↓
Instance.provide (创建/获取实例)
  ↓
Context.provide (设置上下文)
  ↓
各模块使用 state() 访问实例状态
  ↓
Storage 持久化数据
  ↓
GlobalBus 发送事件通知
```

---

## 关键文件索引

| 模块     | 文件路径                                |
| -------- | --------------------------------------- |
| 全局路径 | `src/global/index.ts`                   |
| 上下文   | `src/util/context.ts`                   |
| 实例管理 | `src/project/instance.ts`               |
| 状态管理 | `src/project/state.ts`                  |
| 事件总线 | `src/bus/index.ts`, `src/bus/global.ts` |
| 配置     | `src/config/config.ts`                  |
| 认证     | `src/auth/index.ts`                     |
| 存储     | `src/storage/storage.ts`                |
| 标志     | `src/flag/flag.ts`                      |
| 日志     | `src/util/log.ts`                       |
| 安装     | `src/installation/index.ts`             |
| 项目     | `src/project/project.ts`                |
| 会话     | `src/session/index.ts`                  |

---

## 最佳实践

1. **实例隔离**: 所有实例级状态都应通过 `Instance.state()` 创建
2. **上下文使用**: 在异步操作中通过 `Instance.directory/worktree/project` 访问上下文
3. **事件驱动**: 跨模块通信优先使用 Bus.publish/subscribe
4. **持久化**: 使用 Storage 接口统一管理数据持久化
5. **清理资源**: 在 dispose 函数中正确清理资源
6. **错误处理**: 使用 NamedError 定义错误类型

---

## 注意事项

1. **AsyncLocalStorage 限制**: 必须在异步操作链中保持，不能跨事件循环
2. **并发安全**: Storage 使用文件锁，其他模块需要自行处理
3. **内存管理**: 缓存的实例需要手动 dispose
4. **事件泄漏**: 订阅事件后记得取消订阅
5. **版本兼容**: 数据迁移时需要考虑向后兼容
