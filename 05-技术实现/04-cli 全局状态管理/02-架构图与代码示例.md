# 全局状态管理 - 架构图与代码示例

## 1. 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      CLI 入口 (src/index.ts)                  │
│                    yargs + middleware                          │
└─────────────────────────┬───────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                    全局层 (Global)                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │Global.Path  │  │   Log       │  │ Installation│        │
│  │- home       │  │- level      │  │- VERSION    │        │
│  │- data       │  │- loggers    │  │- CHANNEL    │        │
│  │- config     │  │- write()    │  │- USER_AGENT │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   Flag      │  │GlobalBus    │  │   Auth      │        │
│  │- 环境变量    │  │EventEmitter │  │- tokens     │        │
│  │- 功能开关    │  │- 跨实例事件  │  │- auth.json  │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────┬───────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│              Instance.provide() - 实例创建/获取               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  cache.get(directory) → 命中?                         │   │
│  │    ├─ YES: 复用已有实例                                │   │
│  │    └─ NO:  Project.fromDirectory() 创建新实例          │   │
│  │         ├─ 检测 git 仓库                              │   │
│  │         ├─ 生成 project ID                            │   │
│  │         ├─ 保存到 Storage                             │   │
│  │         └─ cache.set(directory)                        │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────┬───────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│            AsyncLocalStorage (Context)                       │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  context.provide({                                  │   │
│  │    directory,                                       │   │
│  │    worktree,                                        │   │
│  │    project                                          │   │
│  │  }, async () => {                                   │   │
│  │    // 所有子异步操作都能访问这个上下文                │   │
│  │  })                                                 │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────┬───────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│               实例级状态 (Instance.state)                    │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   Config    │  │    Bus      │  │  Session    │        │
│  │- config     │  │- subscribe  │  │- messages   │        │
│  │- directories│  │- publish    │  │- history    │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │   Project   │  │  Storage    │  │    IDE      │        │
│  │- id         │  │- read/write │  │- install    │        │
│  │- worktree   │  │- update     │  │- detect     │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────┬───────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                   State 状态管理机制                          │
│  recordsByKey: Map<directory, Map<init, Entry>>            │
│                                                              │
│  每个实例独立状态:                                           │
│  Instance.directory (getter) →                            │
│    ├─ Config.state()  →  { config, directories }           │
│    ├─ Bus.state()     →  { subscriptions }                │
│    └─ ...                                                      │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                   Storage 持久化层                            │
│  Global.Path.data/storage/                                   │
│  ├── project/                  ← 项目元数据                  │
│  │   ├── {projectID}.json                                   │
│  ├── session/{projectID}/     ← 会话数据                    │
│  │   ├── {sessionID}.json                                  │
│  ├── message/                  ← 消息数据                    │
│  │   ├── {messageID}/                                   │
│  │   │   └── {partID}.json                                 │
│  └── auth.json                 ← 认证令牌                   │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. 核心机制详解

### 2.1 Instance 管理流程

```typescript
// 伪代码：完整流程
async function runCommand(directory: string) {
  // 1. 检查缓存
  let existing = cache.get(directory)

  if (!existing) {
    // 2. 创建新实例
    existing = createInstance(directory)
    cache.set(directory, existing)
  }

  // 3. 提供上下文
  const ctx = await existing
  return context.provide(ctx, async () => {
    // 4. 执行业务逻辑
    // 在这里，所有的异步操作都能通过 Instance.directory/worktree/project 访问上下文
    const config = await Config.get()
    const sessions = await Session.list()
    // ...
  })
}
```

### 2.2 State 创建和使用

```typescript
// 定义状态
const state = Instance.state(
  // 初始化函数
  () => {
    return {
      data: new Map<string, any>(),
      timestamp: Date.now(),
    }
  },
  // 清理函数
  async (state) => {
    state.data.clear()
  },
)

// 使用状态
function doSomething() {
  // 首次调用：执行初始化
  const state1 = state()

  // 后续调用：返回同一个实例
  const state2 = state()

  state1 === state2 // true
}
```

### 2.3 事件发布/订阅

```typescript
// 定义事件
const UserChanged = BusEvent.define(
  "user.changed",
  z.object({
    userID: z.string(),
    name: z.string(),
  }),
)

// 发布事件
await Bus.publish(UserChanged, {
  userID: "123",
  name: "Alice",
})

// 订阅事件
const unsub = Bus.subscribe(UserChanged, (event) => {
  console.log(event.type) // "user.changed"
  console.log(event.properties) // { userID: "123", name: "Alice" }
})

// 取消订阅
unsub()

// 一次性订阅
Bus.once(UserChanged, (event) => {
  console.log("只执行一次")
  return "done" // 返回 "done" 会自动取消订阅
})

// 订阅所有事件
Bus.subscribeAll((event) => {
  console.log("所有事件:", event.type)
})
```

### 2.4 Config 加载流程

```typescript
// 伪代码：配置加载
async function loadConfig() {
  let result = {}

  // 1. 全局配置（低优先级）
  result = merge(result, loadFile("~/.config/opencode/config.json"))

  // 2. 项目配置（中优先级）
  const projectConfigs = findUp(["opencode.json", "opencode.jsonc"], directory)
  for (const config of projectConfigs) {
    result = merge(result, loadFile(config))
  }

  // 3. 环境变量覆盖（高优先级）
  if (Flag.OPENCODE_CONFIG) {
    result = merge(result, loadFile(Flag.OPENCODE_CONFIG))
  }

  // 4. .opencode 目录加载
  for (const dir of configDirectories) {
    result = merge(result, await loadCommand(dir))
    result = merge(result, await loadAgent(dir))
    result = merge(result, await loadPlugin(dir))
  }

  // 5. Flag 覆盖（最高优先级）
  if (Flag.OPENCODE_DISABLE_AUTOUPDATE) {
    result.autoupdate = false
  }

  return result
}
```

### 2.5 Storage 操作模式

```typescript
// 读取
const session = await Storage.read<Session.Info>(["session", projectID, sessionID])

// 写入
await Storage.write(["session", projectID, sessionID], {
  id: "123",
  title: "My Session",
  // ...
})

// 更新（原子操作）
const updated = await Storage.update(["session", projectID, sessionID], (draft) => {
  draft.title = "New Title"
  draft.time.updated = Date.now()
})

// 删除
await Storage.remove(["session", projectID, sessionID])

// 列表
const sessions = await Storage.list(["session", projectID])
// ["session", "project123", "abc"]
// ["session", "project123", "def"]
```

---

## 3. 关键代码片段

### 3.1 Context 实现 (src/util/context.ts)

```typescript
import { AsyncLocalStorage } from "async_hooks"

export namespace Context {
  export class NotFound extends Error {
    constructor(public override readonly name: string) {
      super(`No context found for ${name}`)
    }
  }

  export function create<T>(name: string) {
    const storage = new AsyncLocalStorage<T>()

    return {
      use() {
        const result = storage.getStore()
        if (!result) {
          throw new NotFound(name)
        }
        return result
      },

      provide<R>(value: T, fn: () => R) {
        return storage.run(value, fn)
      },
    }
  }
}
```

**关键点**:

- 使用 Node.js 原生 `AsyncLocalStorage`
- 支持嵌套上下文（内层覆盖外层）
- 超出上下文范围自动清理

### 3.2 Instance.state 实现 (src/project/instance.ts)

```typescript
export const Instance = {
  // ... 其他方法

  state<S>(init: () => S, dispose?: (state: Awaited<S>) => Promise<void>): () => S {
    return State.create(() => Instance.directory, init, dispose)
  },
}
```

```typescript
// State.create 实现 (src/project/state.ts)
const recordsByKey = new Map<string, Map<any, Entry>>()

export function create<S>(root: () => string, init: () => S, dispose?: (state: Awaited<S>) => Promise<void>) {
  return () => {
    // 1. 获取 key (通常是目录路径)
    const key = root()

    // 2. 获取该 key 下的所有状态
    let entries = recordsByKey.get(key)
    if (!entries) {
      entries = new Map<string, Entry>()
      recordsByKey.set(key, entries)
    }

    // 3. 检查是否已初始化
    const exists = entries.get(init)
    if (exists) return exists.state as S

    // 4. 创建新状态
    const state = init()
    entries.set(init, {
      state,
      dispose,
    })

    return state
  }
}
```

**关键点**:

- 使用 init 函数作为 key，确保相同初始化逻辑返回同一个实例
- init 函数可以返回普通值或 Promise，都会被正确处理
- 提供清理钩子

### 3.3 Bus 发布/订阅实现 (src/bus/index.ts)

```typescript
export async function publish<Definition extends BusEvent.Definition>(
  def: Definition,
  properties: z.output<Definition["properties"]>,
) {
  const payload = {
    type: def.type,
    properties,
  }

  log.info("publishing", { type: def.type })

  const pending = []

  // 订阅特定类型的事件
  const match = state().subscriptions.get(def.type)
  if (match) {
    for (const sub of match) {
      pending.push(sub(payload))
    }
  }

  // 订阅所有事件（通配符）
  const wildcard = state().subscriptions.get("*")
  if (wildcard) {
    for (const sub of wildcard) {
      pending.push(sub(payload))
    }
  }

  // 同时发送到全局事件总线
  GlobalBus.emit("event", {
    directory: Instance.directory,
    payload,
  })

  return Promise.all(pending)
}
```

**实际代码实现**:

```typescript
// 实际代码中使用循环同时处理特定类型和通配符
const pending = []
for (const key of [def.type, "*"]) {
  const match = state().subscriptions.get(key)
  for (const sub of match ?? []) {
    pending.push(sub(payload))
  }
}
```

**关键点**:

- 支持同步和异步订阅
- 通配符订阅所有事件
- 全局事件总线跨实例通信

### 3.4 Config 深度合并 (src/config/config.ts)

```typescript
import { mergeDeep } from "remeda"

function mergeConfigWithPlugins(target: Info, source: Info): Info {
  const merged = mergeDeep(target, source)

  // 插件数组特殊处理：拼接而非替换
  if (target.plugin && source.plugin) {
    const pluginSet = new Set([...target.plugin, ...source.plugin])
    merged.plugin = Array.from(pluginSet)
  }

  return merged
}
```

**使用示例**:

```typescript
const base = {
  plugin: ["plugin-a"],
  agent: {
    build: { model: "claude-2" },
  },
}

const override = {
  plugin: ["plugin-b"],
  agent: {
    build: { temperature: 0.7 },
  },
}

const merged = mergeConfigWithPlugins(base, override)
// {
//   plugin: ["plugin-a", "plugin-b"],  // 拼接
//   agent: {
//     build: {
//       model: "claude-2",              // 深度合并
//       temperature: 0.7
//     }
//   }
// }
```

### 3.5 Storage 文件锁 (src/storage/storage.ts)

```typescript
import { Lock } from "../util/lock"

export async function update<T>(key: string[], fn: (draft: T) => void) {
  const dir = await state().then((x) => x.dir)
  const target = path.join(dir, ...key) + ".json"

  return withErrorHandling(async () => {
    // 获取写锁
    using _ = await Lock.write(target)

    // 读取内容
    const content = await Bun.file(target).json()

    // 修改内容
    fn(content)

    // 写入文件
    await Bun.write(target, JSON.stringify(content, null, 2))

    return content as T
  })
}
```

**关键点**:

- 使用 `using` 语法自动释放锁
- 支持并发安全的读写操作

---

## 4. 实战示例

### 4.1 创建自定义实例状态

```typescript
// 在你的模块中
import { Instance } from "../project/instance"
import { Log } from "../util/log"

const log = Log.create({ service: "mymodule" })

const state = Instance.state(
  () => {
    log.info("initializing state")
    return {
      cache: new Map<string, any>(),
      counter: 0,
    }
  },
  async (state) => {
    log.info("disposing state")
    state.cache.clear()
  },
)

export async function doWork() {
  // 获取当前实例的状态
  const s = state()

  s.counter++
  s.cache.set("key", "value")

  return s.counter
}
```

### 4.2 订阅会话事件

```typescript
import { Bus } from "../bus"
import { Session } from "../session"

// 订阅会话创建事件
const unsub = Bus.subscribe(Session.Event.Created, (event) => {
  const { info } = event.properties
  console.log(`会话创建: ${info.id}`)
  console.log(`项目: ${info.projectID}`)
})

// 订阅会话更新事件
Bus.subscribe(Session.Event.Updated, (event) => {
  const { info } = event.properties
  console.log(`会话更新: ${info.id}`)
})

// 订阅所有事件
Bus.subscribeAll((event) => {
  console.log(`[事件] ${event.type}`)
})

// 在适当的时候取消订阅
unsub()
```

### 4.3 跨实例通信

```typescript
import { GlobalBus } from "../bus/global"
import { Session } from "../session"

// 监听全局事件
GlobalBus.on("event", ({ directory, payload }) => {
  if (payload.type === Session.Event.Updated.type) {
    console.log(`实例 ${directory} 的会话已更新`)
  }
})
```

### 4.4 自定义配置加载

```typescript
import { Config } from "../config/config"

// 获取当前配置
const config = await Config.get()

// 获取配置目录
const directories = await Config.directories()

// 更新配置
await Config.update({
  theme: "dark",
  keybinds: {
    app_exit: "ctrl+q",
  },
})

// 注意：更新配置后会自动重新加载
```

---

## 5. 调试技巧

### 5.1 查看当前实例信息

```typescript
import { Instance } from "../project/instance"

console.log("当前目录:", Instance.directory)
console.log("工作树:", Instance.worktree)
console.log("项目 ID:", Instance.project.id)
console.log("项目名称:", Instance.project.name)
```

### 5.2 查看所有缓存的实例

```typescript
import { Instance } from "../project/instance"

// 这需要访问内部 cache，仅用于调试
// 实际代码中不应该直接访问
console.log("缓存的实例数量:", cache.size)
for (const [directory] of cache) {
  console.log("  -", directory)
}
```

### 5.3 查看所有事件

```typescript
import { BusEvent } from "../bus/bus-event"

// 查看所有已定义的事件
for (const [type, def] of BusEvent.registry) {
  console.log(type, def.properties)
}
```

### 5.4 监控状态变化

```typescript
import { GlobalBus } from "../bus/global"
import { Session, Project } from ".."

GlobalBus.on("event", ({ directory, payload }) => {
  console.log(`[${directory}] ${payload.type}`)
})
```

---

## 6. 性能优化建议

### 6.1 避免重复初始化

```typescript
// ❌ 不好：每次都创建新状态
function bad() {
  const state = Instance.state(() => expensiveOperation())
  return state()
}

// ✅ 好：状态只创建一次
const goodState = Instance.state(() => expensiveOperation())
function good() {
  return goodState()
}
```

### 6.2 使用 lazy 加载

```typescript
import { lazy } from "../util/lazy"

const heavyData = lazy(async () => {
  return await loadHeavyData()
})

export async function useData() {
  // 首次调用时才加载
  return await heavyData()
}
```

### 6.3 取消未使用的订阅

```typescript
// ✅ 记得取消订阅
const unsub = Bus.subscribe(Event, handler)

// 使用完后
unsub()

// ✅ 使用 once 自动取消
Bus.once(Event, (event) => {
  // 只执行一次
})
```

### 6.4 及时释放实例

```typescript
// 处理完项目后，及时释放
await Instance.dispose()

// 或者释放所有实例
await Instance.disposeAll()
```

---

## 7. 常见问题

### Q1: 为什么有时候获取不到上下文？

**A**: 必须在 `Instance.provide()` 或 `Context.provide()` 的异步回调中使用：

```typescript
// ❌ 错误：不在上下文中
const config = await Config.get()

// ✅ 正确：在上下文中
// Instance.provide 接受一个对象，包含 directory 和 fn 属性
await Instance.provide({
  directory: process.cwd(),
  async fn() {
    const config = await Config.get() // ✅
  },
})
```

### Q2: 事件订阅不生效？

**A**: 检查是否在正确的实例上下文中：

```typescript
// 实例级事件只在当前实例中触发
await Instance.provide({
  directory: "/project1",
  async fn() {
    Bus.subscribe(Event, handler) // 只监听 project1 的事件
  },
})

// 跨实例事件使用 GlobalBus
GlobalBus.on("event", ({ directory, payload }) => {
  // 所有实例的事件
})
```

### Q3: 如何实现全局单例？

**A**: 使用模块级别的变量：

```typescript
let globalState: MyState | null = null

export function getGlobalState() {
  if (!globalState) {
    globalState = createMyState()
  }
  return globalState
}
```

### Q4: 状态没有清理？

**A**: 确保实现 dispose 函数并调用 Instance.dispose()：

```typescript
const state = Instance.state(
  () => createHeavyResource(),
  async (state) => {
    await state.cleanup() // 实现清理逻辑
  },
)

// 及时释放
await Instance.dispose()
```

---

## 8. 最佳实践总结

1. **状态隔离**: 每个项目使用独立的实例状态
2. **资源清理**: 实现 dispose 并及时调用
3. **事件驱动**: 优先使用事件而非直接调用
4. **延迟加载**: 使用 lazy 和 state 延迟初始化
5. **上下文感知**: 始终在正确的上下文中操作
6. **取消订阅**: 订阅后记得取消，避免内存泄漏
7. **并发安全**: 使用 Storage 的文件锁机制
8. **类型安全**: 使用 Zod 定义事件和配置的 schema

---

## 9. 测试与验证

### 运行测试

在 opencode 代码库中，可以通过以下命令测试全局状态管理相关的功能：

```bash
# 进入 opencode 包目录
cd packages/opencode

# 运行所有测试
bun test

# 运行特定模块的测试（需要先配置测试过滤器）
bun test --filter=state
bun test --filter=bus
bun test --filter=config
bun test --filter=storage

# 运行开发服务器（用于实际测试 CLI 行为）
bun dev
```

### 调试技巧

1. **查看实例缓存状态**（仅用于开发调试）:

   ```typescript
   import { Instance } from "../project/instance"

   // 注意：直接访问内部 cache 仅用于调试
   // 实际代码中不应该这样做
   console.log("缓存中的实例:", cache.keys())
   ```

2. **监控事件流**:

   ```typescript
   import { GlobalBus } from "../bus/global"

   GlobalBus.on("event", ({ directory, payload }) => {
     console.log(`[${new Date().toISOString()}] ${directory} -> ${payload.type}`)
   })
   ```

3. **验证状态清理**:

   ```typescript
   const state = Instance.state(
     () => ({ count: 0 }),
     async (s) => {
       console.log("清理状态，当前值:", s.count)
     },
   )

   // 使用后清理
   await Instance.dispose()
   ```

### 常见测试场景

- **测试单例行为**: 多次调用 `Instance.state()` 应该返回同一个实例
- **测试跨实例隔离**: 不同项目的状态应该完全独立
- **测试事件传播**: 实例内事件和全局事件的触发顺序
- **测试配置合并**: 多个配置源的优先级和合并逻辑
